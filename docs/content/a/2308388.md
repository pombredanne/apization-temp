---
title: "[Q#2308188][A#2308388] getResourceAsStream() vs FileInputStream"
question_title: "getResourceAsStream() vs FileInputStream"
question_text: "I was trying to load a file in a webapp, and I was getting a FileNotFound exception when I used FileInputStream. However, using the same path, I was able to load the file when I did getResourceAsStream().  What is the difference between the two methods, and why does one work while the other doesn't?"
answer_text: "The java.io.File and consorts acts on the local disk file system. The root cause of your problem is that relative paths in java.io are dependent on the current working directory. I.e. the directory from which the JVM (in your case: the webserver's one) is started. This may for example be C:\\Tomcat\\bin or something entirely different, but thus not C:\\Tomcat\\webapps\\contextname or whatever you'd expect it to be. In a normal Eclipse project, that would be C:\\Eclipse\\workspace\\projectname. You can learn about the current working directory the following way: However, the working directory is in no way programmatically controllable. You should really prefer using absolute paths in the File API instead of relative paths. E.g. C:\\full\\path\\to\\file.ext. You don't want to hardcode or guess the absolute path in Java (web)applications. That's only portability trouble (i.e. it runs in system X, but not in system Y). The normal practice is to place those kind of resources in the classpath, or to add its full path to the classpath (in an IDE like Eclipse that's the src folder and the \"build path\" respectively). This way you can grab them with help of the ClassLoader by  ClassLoader#getResource() or ClassLoader#getResourceAsStream(). It is able to locate files relative to the \"root\" of the classpath, as you by coincidence figured out. In webapplications (or any other application which uses multiple classloaders) it's recommend to use the ClassLoader as returned by Thread.currentThread().getContextClassLoader() for this so you can look \"outside\" the webapp context as well. Another alternative in webapps is the ServletContext#getResource() and its counterpart ServletContext#getResourceAsStream(). It is able to access files located in the public web folder of the webapp project, including the /WEB-INF folder. The ServletContext is available in servlets by the inherited getServletContext() method, you can call it as-is."
apization_code: "package com.stackoverflow.api;  import com.gargoylesoftware.htmlunit.javascript.host.file.File;  /**  * getResourceAsStream() vs FileInputStream  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/2308388\">https://stackoverflow.com/a/2308388</a>  */ public class APIzator2308388 {    public static String getresourceasstream() throws RuntimeException {     return new File(\".\").getAbsolutePath();   } }"
---

https://stackoverflow.com/q/2308188

I was trying to load a file in a webapp, and I was getting a FileNotFound exception when I used FileInputStream. However, using the same path, I was able to load the file when I did getResourceAsStream(). 
What is the difference between the two methods, and why does one work while the other doesn&#x27;t?



## Original code snippet

https://stackoverflow.com/a/2308388

The java.io.File and consorts acts on the local disk file system. The root cause of your problem is that relative paths in java.io are dependent on the current working directory. I.e. the directory from which the JVM (in your case: the webserver&#x27;s one) is started. This may for example be C:\Tomcat\bin or something entirely different, but thus not C:\Tomcat\webapps\contextname or whatever you&#x27;d expect it to be. In a normal Eclipse project, that would be C:\Eclipse\workspace\projectname. You can learn about the current working directory the following way:
However, the working directory is in no way programmatically controllable. You should really prefer using absolute paths in the File API instead of relative paths. E.g. C:\full\path\to\file.ext.
You don&#x27;t want to hardcode or guess the absolute path in Java (web)applications. That&#x27;s only portability trouble (i.e. it runs in system X, but not in system Y). The normal practice is to place those kind of resources in the classpath, or to add its full path to the classpath (in an IDE like Eclipse that&#x27;s the src folder and the &quot;build path&quot; respectively). This way you can grab them with help of the ClassLoader by  ClassLoader#getResource() or ClassLoader#getResourceAsStream(). It is able to locate files relative to the &quot;root&quot; of the classpath, as you by coincidence figured out. In webapplications (or any other application which uses multiple classloaders) it&#x27;s recommend to use the ClassLoader as returned by Thread.currentThread().getContextClassLoader() for this so you can look &quot;outside&quot; the webapp context as well.
Another alternative in webapps is the ServletContext#getResource() and its counterpart ServletContext#getResourceAsStream(). It is able to access files located in the public web folder of the webapp project, including the /WEB-INF folder. The ServletContext is available in servlets by the inherited getServletContext() method, you can call it as-is.

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
System.out.println(new File(".").getAbsolutePath());
```

## Produced APIzation

[`APIzator2308388.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator2308388.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import com.gargoylesoftware.htmlunit.javascript.host.file.File;

/**
 * getResourceAsStream() vs FileInputStream
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/2308388">https://stackoverflow.com/a/2308388</a>
 */
public class APIzator2308388 {

  public static String getresourceasstream() throws RuntimeException {
    return new File(".").getAbsolutePath();
  }
}

```