---
title: "[Q#11620103][A#11620196] Mockito: Trying to spy on method is calling the original method"
question_title: "Mockito: Trying to spy on method is calling the original method"
question_text: "I'm using Mockito 1.9.0.  I want mock the behaviour for a single method of a class in a JUnit test, so I have The problem is, in the second line, myClassSpy.method1() is actually getting called, resulting in an exception.  The only reason I'm using mocks is so that later, whenever myClassSpy.method1() is called, the real method won't be called and the myResults object will be returned. MyClass is an interface and myInstance is an implementation of that, if that matters. What do I need to do to correct this spying behaviour?"
answer_text: "Let me quote the official documentation: Sometimes it's impossible to use when(Object) for stubbing spies. Example: In your case it goes something like:"
apization_code: "package com.stackoverflow.api;  import java.util.LinkedList; import java.util.List;  /**  * Mockito: Trying to spy on method is calling the original method  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/11620196\">https://stackoverflow.com/a/11620196</a>  */ public class APIzator11620196 {    public static void callMethod() throws RuntimeException {     List list = new LinkedList();     List spy = spy(list);     // Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)     when(spy.get(0)).thenReturn(\"foo\");     // You have to use doReturn() for stubbing     doReturn(\"foo\").when(spy).get(0);     doReturn(resulstIWant).when(myClassSpy).method1();   } }"
---

https://stackoverflow.com/q/11620103

I&#x27;m using Mockito 1.9.0.  I want mock the behaviour for a single method of a class in a JUnit test, so I have
The problem is, in the second line, myClassSpy.method1() is actually getting called, resulting in an exception.  The only reason I&#x27;m using mocks is so that later, whenever myClassSpy.method1() is called, the real method won&#x27;t be called and the myResults object will be returned.
MyClass is an interface and myInstance is an implementation of that, if that matters.
What do I need to do to correct this spying behaviour?


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
final MyClass myClassSpy = Mockito.spy(myInstance);
Mockito.when(myClassSpy.method1()).thenReturn(myResults);
```


## Original code snippet

https://stackoverflow.com/a/11620196

Let me quote the official documentation:
Sometimes it&#x27;s impossible to use when(Object) for stubbing spies. Example:
In your case it goes something like:

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
List list = new LinkedList();
List spy = spy(list);

// Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
when(spy.get(0)).thenReturn("foo");

// You have to use doReturn() for stubbing
doReturn("foo").when(spy).get(0);
doReturn(resulstIWant).when(myClassSpy).method1();
```

## Produced APIzation

[`APIzator11620196.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator11620196.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import java.util.LinkedList;
import java.util.List;

/**
 * Mockito: Trying to spy on method is calling the original method
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/11620196">https://stackoverflow.com/a/11620196</a>
 */
public class APIzator11620196 {

  public static void callMethod() throws RuntimeException {
    List list = new LinkedList();
    List spy = spy(list);
    // Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
    when(spy.get(0)).thenReturn("foo");
    // You have to use doReturn() for stubbing
    doReturn("foo").when(spy).get(0);
    doReturn(resulstIWant).when(myClassSpy).method1();
  }
}

```