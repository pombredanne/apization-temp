---
title: "[Q#875467][A#882479] Java client certificates over HTTPS/SSL"
question_title: "Java client certificates over HTTPS/SSL"
question_text: "I am using Java 6 and am trying to create an HttpsURLConnection against a remote server, using a client certificate. The server is using an selfsigned root certificate, and requires that a password-protected client certificate is presented. I've added the server root certificate and the client certificate to a default java keystore which I found in /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home/lib/security/cacerts (OSX 10.5). The name of the keystore file seems to suggest that the client certificate is not supposed to go in there? Anyway, adding the root certificate to this store solved the infamous javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed' problem. However, I'm now stuck on how to use the client certificate. I've tried two approaches and neither gets me anywhere. First, and preferred, try: I've tried skipping the HttpsURLConnection class (not ideal since I want to talk HTTP with the server), and do this instead: I am not even sure that the client certificate is the problem here."
answer_text: "Finally solved it ;). Got a strong hint here (Gandalfs answer touched a bit on it as well). The missing links was (mostly) the first of the parameters below, and to some extent that I overlooked the difference between keystores and truststores. The self-signed server certificate must be imported into a truststore: keytool -import -alias gridserver -file gridserver.crt -storepass $PASS -keystore gridserver.keystore These properties need to be set (either on the commandline, or in code): Working example code:"
apization_code: "package com.stackoverflow.api;  import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLSocketFactory;  /**  * Java client certificates over HTTPS/SSL  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/882479\">https://stackoverflow.com/a/882479</a>  */ public class APIzator882479 {    public static void certificate() throws RuntimeException {     SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();     URL url = new URL(\"https://gridserver:3049/cgi-bin/ls.py\");     HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();     conn.setSSLSocketFactory(sslsocketfactory);     InputStream inputstream = conn.getInputStream();     InputStreamReader inputstreamreader = new InputStreamReader(inputstream);     BufferedReader bufferedreader = new BufferedReader(inputstreamreader);     String string = null;     while ((string = bufferedreader.readLine()) != null) {       System.out.println(\"Received \" + string);     }   } }"
---

https://stackoverflow.com/q/875467

I am using Java 6 and am trying to create an HttpsURLConnection against a remote server, using a client certificate.
The server is using an selfsigned root certificate, and requires that a password-protected client certificate is presented. I&#x27;ve added the server root certificate and the client certificate to a default java keystore which I found in /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home/lib/security/cacerts (OSX 10.5).
The name of the keystore file seems to suggest that the client certificate is not supposed to go in there?
Anyway, adding the root certificate to this store solved the infamous javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed&#x27; problem.
However, I&#x27;m now stuck on how to use the client certificate. I&#x27;ve tried two approaches and neither gets me anywhere.
First, and preferred, try:
I&#x27;ve tried skipping the HttpsURLConnection class (not ideal since I want to talk HTTP with the server), and do this instead:
I am not even sure that the client certificate is the problem here.


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
URL url = new URL("https://somehost.dk:3049");
HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();
conn.setSSLSocketFactory(sslsocketfactory);
InputStream inputstream = conn.getInputStream();
// The last line fails, and gives:
// javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure
SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket("somehost.dk", 3049);
InputStream inputstream = sslsocket.getInputStream();
// do anything with the inputstream results in:
// java.net.SocketTimeoutException: Read timed out
```


## Original code snippet

https://stackoverflow.com/a/882479

Finally solved it ;). Got a strong hint here (Gandalfs answer touched a bit on it as well). The missing links was (mostly) the first of the parameters below, and to some extent that I overlooked the difference between keystores and truststores.
The self-signed server certificate must be imported into a truststore:
keytool -import -alias gridserver -file gridserver.crt -storepass $PASS -keystore gridserver.keystore
These properties need to be set (either on the commandline, or in code):
Working example code:

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
-Djavax.net.ssl.keyStoreType=pkcs12
-Djavax.net.ssl.trustStoreType=jks
-Djavax.net.ssl.keyStore=clientcertificate.p12
-Djavax.net.ssl.trustStore=gridserver.keystore
-Djavax.net.debug=ssl # very verbose debug
-Djavax.net.ssl.keyStorePassword=$PASS
-Djavax.net.ssl.trustStorePassword=$PASS
SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
URL url = new URL("https://gridserver:3049/cgi-bin/ls.py");
HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();
conn.setSSLSocketFactory(sslsocketfactory);
InputStream inputstream = conn.getInputStream();
InputStreamReader inputstreamreader = new InputStreamReader(inputstream);
BufferedReader bufferedreader = new BufferedReader(inputstreamreader);

String string = null;
while ((string = bufferedreader.readLine()) != null) {
    System.out.println("Received " + string);
}
```

## Produced APIzation

[`APIzator882479.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator882479.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSocketFactory;

/**
 * Java client certificates over HTTPS/SSL
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/882479">https://stackoverflow.com/a/882479</a>
 */
public class APIzator882479 {

  public static void certificate() throws RuntimeException {
    SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
    URL url = new URL("https://gridserver:3049/cgi-bin/ls.py");
    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
    conn.setSSLSocketFactory(sslsocketfactory);
    InputStream inputstream = conn.getInputStream();
    InputStreamReader inputstreamreader = new InputStreamReader(inputstream);
    BufferedReader bufferedreader = new BufferedReader(inputstreamreader);
    String string = null;
    while ((string = bufferedreader.readLine()) != null) {
      System.out.println("Received " + string);
    }
  }
}

```