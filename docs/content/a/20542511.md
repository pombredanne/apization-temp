---
title: "[Q#20541636][A#20542511] Compare non-primitive Long values 127 and 128"
question_title: "Compare non-primitive Long values 127 and 128"
question_text: "I want to compare two Long objects values using if conditions. When these values are less than 128, the if condition works properly, but when they are greater than or equal to 128, comparison fails. Example: Comparison on the code above works properly, but fails in the code below: Why is there a problem in comparing Long variables with values greater than 127? If the variables data types are changed to long primitives, then the comparisons work for all cases."
answer_text: "Why there is problem in comparing Long variable with value greater than 127? If the data type of above variable is primitive (long) then code work for all values. Java caches Integer objects instances from the range -128 to 127. That said: That's why this: Outputs this: true   false For the 127L value, since both references (val1 and val2) point to the same object instance in memory (cached), it returns true. On the other hand, for the 128 value, since there is no instance for it cached in memory, a new one is created for any new assignments for boxed values, resulting in two different instances (pointed by val3 and val4) and returning false on the comparison between them. That happens solely because you are comparing two Long object references, not long primitive values, with the == operator. If it wasn't for this Cache mechanism, these comparisons would always fail, so the real problem here is comparing boxed values with == operator. Changing these variables to primitive long types will prevent this from happening, but in case you need to keep your code using Long objects, you can safely make these comparisons with the following approaches: IMO, it's always a good idea to stick with .equals() methods when dealing with Object comparisons. Disclaimer: Most comparisons will fail if any of these values are null (even casting to long will throw an exception), so additional checkings are needed to accomodate these scenarios. Reference links:"
apization_code: "package com.stackoverflow.api;  /**  * Compare non-primitive Long values 127 and 128  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/20542511\">https://stackoverflow.com/a/20542511</a>  */ public class APIzator20542511 {    public static String compareValue(Long val1, Long val2, Long val3, Long val4)     throws RuntimeException {     System.out.println(val1 == val2);     System.out.println(val3 == val4);     // true     System.out.println(val3.equals(val4));     // true     System.out.println(val3.longValue() == val4.longValue());     return (long) val3 == (long) val4;   } }"
---

https://stackoverflow.com/q/20541636

I want to compare two Long objects values using if conditions. When these values are less than 128, the if condition works properly, but when they are greater than or equal to 128, comparison fails.
Example:
Comparison on the code above works properly, but fails in the code below:
Why is there a problem in comparing Long variables with values greater than 127? If the variables data types are changed to long primitives, then the comparisons work for all cases.


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
Long num1 = 127;
Long num2 = 127;

if (num1 == num2) {
    // Works ok
}
Long num1 = 128;
Long num2 = 128;

if (num1 == num2) {
    // Does NOT work
}
```


## Original code snippet

https://stackoverflow.com/a/20542511

Why there is problem in comparing Long variable with value greater than 127? If the data type of above variable is primitive (long) then code work for all values.
Java caches Integer objects instances from the range -128 to 127. That said:
That&#x27;s why this:
Outputs this:
true
  false
For the 127L value, since both references (val1 and val2) point to the same object instance in memory (cached), it returns true.
On the other hand, for the 128 value, since there is no instance for it cached in memory, a new one is created for any new assignments for boxed values, resulting in two different instances (pointed by val3 and val4) and returning false on the comparison between them.
That happens solely because you are comparing two Long object references, not long primitive values, with the == operator. If it wasn&#x27;t for this Cache mechanism, these comparisons would always fail, so the real problem here is comparing boxed values with == operator.
Changing these variables to primitive long types will prevent this from happening, but in case you need to keep your code using Long objects, you can safely make these comparisons with the following approaches:
IMO, it&#x27;s always a good idea to stick with .equals() methods when dealing with Object comparisons.
Disclaimer: Most comparisons will fail if any of these values are null (even casting to long will throw an exception), so additional checkings are needed to accomodate these scenarios.
Reference links:

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
Long val1 = 127L;
Long val2 = 127L;

System.out.println(val1 == val2);

Long val3 = 128L;
Long val4 = 128L;

System.out.println(val3 == val4);
System.out.println(val3.equals(val4));                     // true
System.out.println(val3.longValue() == val4.longValue());  // true
System.out.println((long)val3 == (long)val4);              // true
```

## Produced APIzation

[`APIzator20542511.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator20542511.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

/**
 * Compare non-primitive Long values 127 and 128
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/20542511">https://stackoverflow.com/a/20542511</a>
 */
public class APIzator20542511 {

  public static String compareValue(Long val1, Long val2, Long val3, Long val4)
    throws RuntimeException {
    System.out.println(val1 == val2);
    System.out.println(val3 == val4);
    // true
    System.out.println(val3.equals(val4));
    // true
    System.out.println(val3.longValue() == val4.longValue());
    return (long) val3 == (long) val4;
  }
}

```