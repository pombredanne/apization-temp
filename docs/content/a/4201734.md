---
title: "[Q#4201713][A#4201734] Synchronization vs Lock"
question_title: "Synchronization vs Lock"
question_text: "java.util.concurrent API provides a class called as Lock, which would basically serialize the control in order to access the critical resource. It gives method such as park() and unpark(). We can do similar things if we can use synchronized keyword and using wait() and notify() notifyAll() methods. I am wondering which one of these is better in practice and why?"
answer_text: "If you're simply locking an object, I'd prefer to use synchronized Example: You have to explicitly do try{} finally{} everywhere. Whereas with synchronized, it's super clear and impossible to get wrong: That said, Locks may be more useful for more complicated things where you can't acquire and release in such a clean manner.  I would honestly prefer to avoid using bare Locks in the first place, and just go with a more sophisticated concurrency control such as a CyclicBarrier or a LinkedBlockingQueue, if they meet your needs. I've never had a reason to use wait() or notify() but there may be some good ones."
apization_code: "package com.stackoverflow.api;  import java.util.concurrent.locks.Lock;  /**  * Synchronization vs Lock  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/4201734\">https://stackoverflow.com/a/4201734</a>  */ public class APIzator4201734 {    public static void synchronization() throws RuntimeException {     Lock.acquire();     // Throws a NPE!     doSomethingNifty();     // Oh noes, we never release the lock!     Lock.release();     synchronized (myObject) {       doSomethingNifty();     }   } }"
---

https://stackoverflow.com/q/4201713

java.util.concurrent API provides a class called as Lock, which would basically serialize the control in order to access the critical resource. It gives method such as park() and unpark().
We can do similar things if we can use synchronized keyword and using wait() and notify() notifyAll() methods.
I am wondering which one of these is better in practice and why?



## Original code snippet

https://stackoverflow.com/a/4201734

If you&#x27;re simply locking an object, I&#x27;d prefer to use synchronized
Example:
You have to explicitly do try{} finally{} everywhere.
Whereas with synchronized, it&#x27;s super clear and impossible to get wrong:
That said, Locks may be more useful for more complicated things where you can&#x27;t acquire and release in such a clean manner.  I would honestly prefer to avoid using bare Locks in the first place, and just go with a more sophisticated concurrency control such as a CyclicBarrier or a LinkedBlockingQueue, if they meet your needs.
I&#x27;ve never had a reason to use wait() or notify() but there may be some good ones.

```java
Lock.acquire();
doSomethingNifty(); // Throws a NPE!
Lock.release(); // Oh noes, we never release the lock!
synchronized(myObject) {
    doSomethingNifty();
}
```

## Produced APIzation

[`APIzator4201734.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator4201734.java)

```java
package com.stackoverflow.api;

import java.util.concurrent.locks.Lock;

/**
 * Synchronization vs Lock
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/4201734">https://stackoverflow.com/a/4201734</a>
 */
public class APIzator4201734 {

  public static void synchronization() throws RuntimeException {
    Lock.acquire();
    // Throws a NPE!
    doSomethingNifty();
    // Oh noes, we never release the lock!
    Lock.release();
    synchronized (myObject) {
      doSomethingNifty();
    }
  }
}

```