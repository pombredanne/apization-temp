---
title: "[Q#77718][A#77963] Why doesn't Java offer operator overloading?"
question_title: "Why doesn't Java offer operator overloading?"
question_text: "Coming from C++ to Java, the obvious unanswered question is why didn't Java include operator overloading? Isn't Complex a, b, c; a = b + c; much simpler than Complex a, b, c; a = b.add(c);? Is there a known reason for this, valid arguments for not allowing operator overloading? Is the reason arbitrary, or lost to time?"
answer_text: "Assuming you wanted to overwrite the previous value of the object referred to by a, then a member function would have to be invoked. In C++, this expression tells the compiler to create three (3) objects on the stack, perform addition, and copy the resultant value from the temporary object into the existing object a. However, in Java, operator= doesn't perform value copy for reference types, and users can only create new reference types, not value types. So for a user-defined type named Complex, assignment means to copy a reference to an existing value. Consider instead: In C++, this copies the value, so the comparison will result not-equal. In Java, operator= performs reference copy, so a and b are now referring to the same value. As a result, the comparison will produce 'equal', since the object will compare equal to itself. The difference between copies and references only adds to the confusion of operator overloading. As @Sebastian mentioned, Java and C# both have to deal with value and reference equality separately -- operator+ would likely deal with values and objects, but operator= is already implemented to deal with references. In C++, you should only be dealing with one kind of comparison at a time, so it can be less confusing. For example, on Complex, operator= and operator== are both working on values -- copying values and comparing values respectively."
apization_code: "package com.stackoverflow.api;  import org.apache.commons.math.complex.Complex;  /**  * Why doesn't Java offer operator overloading?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/77963\">https://stackoverflow.com/a/77963</a>  */ public class APIzator77963 {    public static void offerOperator() throws RuntimeException {     Complex a, b, c;     // ...     a = b.add(c);     // initialize to real number '1'     b.set(1, 0);     a = b;     b.set(2, 0);     assert (!a.equals(b));   } }"
---

https://stackoverflow.com/q/77718

Coming from C++ to Java, the obvious unanswered question is why didn&#x27;t Java include operator overloading?
Isn&#x27;t Complex a, b, c; a = b + c; much simpler than Complex a, b, c; a = b.add(c);?
Is there a known reason for this, valid arguments for not allowing operator overloading? Is the reason arbitrary, or lost to time?



## Original code snippet

https://stackoverflow.com/a/77963

Assuming you wanted to overwrite the previous value of the object referred to by a, then a member function would have to be invoked.
In C++, this expression tells the compiler to create three (3) objects on the stack, perform addition, and copy the resultant value from the temporary object into the existing object a.
However, in Java, operator= doesn&#x27;t perform value copy for reference types, and users can only create new reference types, not value types. So for a user-defined type named Complex, assignment means to copy a reference to an existing value.
Consider instead:
In C++, this copies the value, so the comparison will result not-equal. In Java, operator= performs reference copy, so a and b are now referring to the same value. As a result, the comparison will produce &#x27;equal&#x27;, since the object will compare equal to itself.
The difference between copies and references only adds to the confusion of operator overloading. As @Sebastian mentioned, Java and C# both have to deal with value and reference equality separately -- operator+ would likely deal with values and objects, but operator= is already implemented to deal with references.
In C++, you should only be dealing with one kind of comparison at a time, so it can be less confusing. For example, on Complex, operator= and operator== are both working on values -- copying values and comparing values respectively.

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
Complex a, b, c;
// ...
a = b.add(c);
b.set(1, 0); // initialize to real number '1'
a = b; 
b.set(2, 0);
assert( !a.equals(b) );
```

## Produced APIzation

[`APIzator77963.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator77963.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import org.apache.commons.math.complex.Complex;

/**
 * Why doesn't Java offer operator overloading?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/77963">https://stackoverflow.com/a/77963</a>
 */
public class APIzator77963 {

  public static void offerOperator() throws RuntimeException {
    Complex a, b, c;
    // ...
    a = b.add(c);
    // initialize to real number '1'
    b.set(1, 0);
    a = b;
    b.set(2, 0);
    assert (!a.equals(b));
  }
}

```