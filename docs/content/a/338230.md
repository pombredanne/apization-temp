---
title: "[Q#338206][A#338230] Why can't I use switch statement on a String?"
question_title: "Why can't I use switch statement on a String?"
question_text: "Is this functionality going to be put into a later Java version? Can someone explain why I can't do this, as in, the technical way Java's switch statement works?"
answer_text: "Switch statements with String cases have been implemented in Java SE 7, at least 16 years after they were first requested. A clear reason for the delay was not provided, but it likely had to do with performance. The feature has now been implemented in javac with a \"de-sugaring\" process; a clean, high-level syntax using String constants in case declarations is expanded at compile-time into more complex code following a pattern. The resulting code uses JVM instructions that have always existed. A switch with String cases is translated into two switches during compilation. The first maps each string to a unique integer—its position in the original switch. This is done by first switching on the hash code of the label. The corresponding case is an if statement that tests string equality; if there are collisions on the hash, the test is a cascading if-else-if. The second switch mirrors that in the original source code, but substitutes the case labels with their corresponding positions. This two-step process makes it easy to preserve the flow control of the original switch. For more technical depth on switch, you can refer to the JVM Specification, where the compilation of switch statements is described. In a nutshell, there are two different JVM instructions that can be used for a switch, depending on the sparsity of the constants used by the cases. Both depend on using integer constants for each case to execute efficiently. If the constants are dense, they are used as an index (after subtracting the lowest value) into a table of instruction pointers—the tableswitch instruction. If the constants are sparse, a binary search for the correct case is performed—the lookupswitch instruction. In de-sugaring a switch on String objects, both instructions are likely to be used. The lookupswitch is suitable for the first switch on hash codes to find the original position of the case. The resulting ordinal is a natural fit for a tableswitch. Both instructions require the integer constants assigned to each case to be sorted at compile time. At runtime, while the O(1) performance of tableswitch generally appears better than the O(log(n)) performance of lookupswitch, it requires some analysis to determine whether the table is dense enough to justify the space–time tradeoff. Bill Venners wrote a great article that covers this in more detail, along with an under-the-hood look at other Java flow control instructions. Prior to JDK 7, enum could approximate a String-based switch. This uses the static valueOf method generated by the compiler on every enum type. For example:"
apization_code: "package com.stackoverflow.api;  /**  * Why can't I use switch statement on a String?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/338230\">https://stackoverflow.com/a/338230</a>  */ public class APIzator338230 {    public static void useStatement() throws RuntimeException {     Pill p = Pill.valueOf(str);     switch (p) {       case RED:         pop();         break;       case BLUE:         push();         break;     }   } }"
---

https://stackoverflow.com/q/338206

Is this functionality going to be put into a later Java version?
Can someone explain why I can&#x27;t do this, as in, the technical way Java&#x27;s switch statement works?



## Original code snippet

https://stackoverflow.com/a/338230

Switch statements with String cases have been implemented in Java SE 7, at least 16 years after they were first requested. A clear reason for the delay was not provided, but it likely had to do with performance.
The feature has now been implemented in javac with a &quot;de-sugaring&quot; process; a clean, high-level syntax using String constants in case declarations is expanded at compile-time into more complex code following a pattern. The resulting code uses JVM instructions that have always existed.
A switch with String cases is translated into two switches during compilation. The first maps each string to a unique integer—its position in the original switch. This is done by first switching on the hash code of the label. The corresponding case is an if statement that tests string equality; if there are collisions on the hash, the test is a cascading if-else-if. The second switch mirrors that in the original source code, but substitutes the case labels with their corresponding positions. This two-step process makes it easy to preserve the flow control of the original switch.
For more technical depth on switch, you can refer to the JVM Specification, where the compilation of switch statements is described. In a nutshell, there are two different JVM instructions that can be used for a switch, depending on the sparsity of the constants used by the cases. Both depend on using integer constants for each case to execute efficiently.
If the constants are dense, they are used as an index (after subtracting the lowest value) into a table of instruction pointers—the tableswitch instruction.
If the constants are sparse, a binary search for the correct case is performed—the lookupswitch instruction.
In de-sugaring a switch on String objects, both instructions are likely to be used. The lookupswitch is suitable for the first switch on hash codes to find the original position of the case. The resulting ordinal is a natural fit for a tableswitch.
Both instructions require the integer constants assigned to each case to be sorted at compile time. At runtime, while the O(1) performance of tableswitch generally appears better than the O(log(n)) performance of lookupswitch, it requires some analysis to determine whether the table is dense enough to justify the space–time tradeoff. Bill Venners wrote a great article that covers this in more detail, along with an under-the-hood look at other Java flow control instructions.
Prior to JDK 7, enum could approximate a String-based switch. This uses the static valueOf method generated by the compiler on every enum type. For example:

```java
Pill p = Pill.valueOf(str);
switch(p) {
  case RED:  pop();  break;
  case BLUE: push(); break;
}
```

## Produced APIzation

[`APIzator338230.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator338230.java)

```java
package com.stackoverflow.api;

/**
 * Why can't I use switch statement on a String?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/338230">https://stackoverflow.com/a/338230</a>
 */
public class APIzator338230 {

  public static void useStatement() throws RuntimeException {
    Pill p = Pill.valueOf(str);
    switch (p) {
      case RED:
        pop();
        break;
      case BLUE:
        push();
        break;
    }
  }
}

```