---
title: "[Q#616484][A#616505] How to use ConcurrentLinkedQueue?"
question_title: "How to use ConcurrentLinkedQueue?"
question_text: "How do I use a ConcurrentLinkedQueue in Java? Using this LinkedQueue, do I need to be worried about concurrency in the queue? Or do I just have to define two methods (one to retrive elements from the list and another to add elements to the list)? Note: obviously these two methods have to be synchronized. Right? EDIT: What I'm trying to do is this: I have a class (in Java) with one method to retrieve items from the queue and another class with one method to add items to the queue. The items added and retrieved from the list are objects of my own class. One more question: do I need to do this in the remove method: I only have one consumer and one producer."
answer_text: "No, the methods don't need to be synchronized, and you don't need to define any methods; they are already in ConcurrentLinkedQueue, just use them. ConcurrentLinkedQueue does all the locking and other operations you need internally; your producer(s) adds data into the queue, and your consumers poll for it. First, create your queue: Now, wherever you are creating your producer/consumer objects, pass in the queue so they have somewhere to put their objects (you could use a setter for this, instead, but I prefer to do this kind of thing in a constructor): and: and add stuff to it in your producer: and take stuff out in your consumer (if the queue is empty, poll() will return null, so check it): For more info see the Javadoc If you need to block waiting for the queue to not be empty, you probably want to use a LinkedBlockingQueue, and use the take() method. However, LinkedBlockingQueue has a maximum capacity (defaults to Integer.MAX_VALUE, which is over two billion) and thus may or may not be appropriate depending on your circumstances. If you only have one thread putting stuff into the queue, and another thread taking stuff out of the queue, ConcurrentLinkedQueue is probably overkill. It's more for when you may have hundreds or even thousands of threads accessing the queue at the same time. Your needs will probably be met by using: A plus of this is that it locks on the instance (queue), so you can synchronize on queue to ensure atomicity of composite operations (as explained by Jared). You CANNOT do this with a ConcurrentLinkedQueue, as all operations are done WITHOUT locking on the instance (using java.util.concurrent.atomic variables). You will NOT need to do this if you want to block while the queue is empty, because poll() will simply return null while the queue is empty, and poll() is atomic. Check to see if poll() returns null. If it does, wait(), then try again. No need to lock. Honestly, I'd just use a LinkedBlockingQueue. It is still overkill for your application, but odds are it will work fine. If it isn't performant enough (PROFILE!), you can always try something else, and it means you don't have to deal with ANY synchronized stuff: Everything else is the same. Put probably won't block, because you aren't likely to put two billion objects into the queue."
apization_code: "package com.stackoverflow.api;  import com.google.appengine.api.taskqueue.Queue;  /**  * How to use ConcurrentLinkedQueue?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/616505\">https://stackoverflow.com/a/616505</a>  */ public class APIzator616505 {    public static YourObject useConcurrentlinkedqueue() throws RuntimeException {     Queue<YourObject> queue = new ConcurrentLinkedQueue<YourObject>();     YourProducer producer = new YourProducer(queue);     YourConsumer consumer = new YourConsumer(queue);     queue.offer(myObject);     YourObject myObject = queue.poll();     Queue<YourObject> queue = Collections.synchronizedList(       new LinkedList<YourObject>()     );     BlockingQueue<YourObject> queue = new LinkedBlockingQueue<YourObject>();     // Blocks until queue isn't full.     queue.put(myObject);     return queue.take();   } }"
---

https://stackoverflow.com/q/616484

How do I use a ConcurrentLinkedQueue in Java?
Using this LinkedQueue, do I need to be worried about concurrency in the queue? Or do I just have to define two methods (one to retrive elements from the list and another to add elements to the list)?
Note: obviously these two methods have to be synchronized. Right?
EDIT: What I&#x27;m trying to do is this: I have a class (in Java) with one method to retrieve items from the queue and another class with one method to add items to the queue. The items added and retrieved from the list are objects of my own class.
One more question: do I need to do this in the remove method:
I only have one consumer and one producer.


```java
while (queue.size() == 0){ 
  wait(); 
  queue.poll();
}
```


## Original code snippet

https://stackoverflow.com/a/616505

No, the methods don&#x27;t need to be synchronized, and you don&#x27;t need to define any methods; they are already in ConcurrentLinkedQueue, just use them. ConcurrentLinkedQueue does all the locking and other operations you need internally; your producer(s) adds data into the queue, and your consumers poll for it.
First, create your queue:
Now, wherever you are creating your producer/consumer objects, pass in the queue so they have somewhere to put their objects (you could use a setter for this, instead, but I prefer to do this kind of thing in a constructor):
and:
and add stuff to it in your producer:
and take stuff out in your consumer (if the queue is empty, poll() will return null, so check it):
For more info see the Javadoc
If you need to block waiting for the queue to not be empty, you probably want to use a LinkedBlockingQueue, and use the take() method. However, LinkedBlockingQueue has a maximum capacity (defaults to Integer.MAX_VALUE, which is over two billion) and thus may or may not be appropriate depending on your circumstances.
If you only have one thread putting stuff into the queue, and another thread taking stuff out of the queue, ConcurrentLinkedQueue is probably overkill. It&#x27;s more for when you may have hundreds or even thousands of threads accessing the queue at the same time. Your needs will probably be met by using:
A plus of this is that it locks on the instance (queue), so you can synchronize on queue to ensure atomicity of composite operations (as explained by Jared). You CANNOT do this with a ConcurrentLinkedQueue, as all operations are done WITHOUT locking on the instance (using java.util.concurrent.atomic variables). You will NOT need to do this if you want to block while the queue is empty, because poll() will simply return null while the queue is empty, and poll() is atomic. Check to see if poll() returns null. If it does, wait(), then try again. No need to lock.
Honestly, I&#x27;d just use a LinkedBlockingQueue. It is still overkill for your application, but odds are it will work fine. If it isn&#x27;t performant enough (PROFILE!), you can always try something else, and it means you don&#x27;t have to deal with ANY synchronized stuff:
Everything else is the same. Put probably won&#x27;t block, because you aren&#x27;t likely to put two billion objects into the queue.

```java
Queue<YourObject> queue = new ConcurrentLinkedQueue<YourObject>();
YourProducer producer = new YourProducer(queue);
YourConsumer consumer = new YourConsumer(queue);
queue.offer(myObject);
YourObject myObject = queue.poll();
Queue<YourObject> queue = Collections.synchronizedList(new LinkedList<YourObject>());
BlockingQueue<YourObject> queue = new LinkedBlockingQueue<YourObject>();

queue.put(myObject); // Blocks until queue isn't full.

YourObject myObject = queue.take(); // Blocks until queue isn't empty.
```

## Produced APIzation

[`APIzator616505.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator616505.java)

```java
package com.stackoverflow.api;

import com.google.appengine.api.taskqueue.Queue;

/**
 * How to use ConcurrentLinkedQueue?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/616505">https://stackoverflow.com/a/616505</a>
 */
public class APIzator616505 {

  public static YourObject useConcurrentlinkedqueue() throws RuntimeException {
    Queue<YourObject> queue = new ConcurrentLinkedQueue<YourObject>();
    YourProducer producer = new YourProducer(queue);
    YourConsumer consumer = new YourConsumer(queue);
    queue.offer(myObject);
    YourObject myObject = queue.poll();
    Queue<YourObject> queue = Collections.synchronizedList(
      new LinkedList<YourObject>()
    );
    BlockingQueue<YourObject> queue = new LinkedBlockingQueue<YourObject>();
    // Blocks until queue isn't full.
    queue.put(myObject);
    return queue.take();
  }
}

```