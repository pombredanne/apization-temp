---
title: "[Q#992019][A#992413] Java 256-bit AES Password-Based Encryption"
question_title: "Java 256-bit AES Password-Based Encryption"
question_text: "I need to implement 256 bit AES encryption, but all the examples I have found online use a \"KeyGenerator\" to generate a 256 bit key, but I would like to use my own passkey. How can I create my own key? I have tried padding it out to 256 bits, but then I get an error saying that the key is too long. I do have the unlimited jurisdiction patch installed, so thats not the problem :) Ie. The KeyGenerator looks like this ... Code taken from here EDIT I was actually padding the password out to 256 bytes, not bits, which is too long. The following is some code I am using now that I have some more experience with this. The \"TODO\" bits you need to do yourself :-)"
answer_text: "Share the password (a char[]) and salt (a byte[]—8 bytes selected by a SecureRandom makes a good salt—which doesn't need to be kept secret) with the recipient out-of-band. Then to derive a good key from this information: The magic numbers (which could be defined as constants somewhere) 65536 and 256 are the key derivation iteration count and the key size, respectively. The key derivation function is iterated to require significant computational effort, and that prevents attackers from quickly trying many different passwords. The iteration count can be changed depending on the computing resources available. The key size can be reduced to 128 bits, which is still considered \"strong\" encryption, but it doesn't give much of a safety margin if attacks are discovered that weaken AES. Used with a proper block-chaining mode, the same derived key can be used to encrypt many messages. In CBC, a random initialization vector (IV) is generated for each message, yielding different cipher text even if the plain text is identical. CBC may not be the most secure mode available to you (see AEAD below); there are many other modes with different security properties, but they all use a similar random input. In any case, the outputs of each encryption operation are the cipher text and the initialization vector: Store the ciphertext and the iv. On decryption, the SecretKey is regenerated in exactly the same way, using using the password with the same salt and iteration parameters. Initialize the cipher with this key and the initialization vector stored with the message: Java 7 included API support for AEAD cipher modes, and the \"SunJCE\" provider included with OpenJDK and Oracle distributions implements these beginning with Java 8. One of these modes is strongly recommended in place of CBC; it will protect the integrity of the data as well as their privacy. A java.security.InvalidKeyException with the message \"Illegal key size or default parameters\" means that the cryptography strength is limited; the unlimited strength jurisdiction policy files are not in the correct location. In a JDK, they should be placed under ${jdk}/jre/lib/security Based on the problem description, it sounds like the policy files are not correctly installed. Systems can easily have multiple Java runtimes; double-check to make sure that the correct location is being used."
apization_code: "package com.stackoverflow.api;  import java.security.AlgorithmParameters; import java.security.spec.KeySpec; import javax.crypto.Cipher; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; import javax.crypto.spec.SecretKeySpec;  /**  * Java 256-bit AES Password-Based Encryption  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/992413\">https://stackoverflow.com/a/992413</a>  */ public class APIzator992413 {    public static String encryption() throws RuntimeException {     /* Derive the key, given password and salt. */     SecretKeyFactory factory = SecretKeyFactory.getInstance(       \"PBKDF2WithHmacSHA256\"     );     KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);     SecretKey tmp = factory.generateSecret(spec);     SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");     /* Encrypt the message. */     Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");     cipher.init(Cipher.ENCRYPT_MODE, secret);     AlgorithmParameters params = cipher.getParameters();     byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();     byte[] ciphertext = cipher.doFinal(\"Hello, World!\".getBytes(\"UTF-8\"));     /* Decrypt the message, given derived key and initialization vector. */     Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");     cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));     String plaintext = new String(cipher.doFinal(ciphertext), \"UTF-8\");     return plaintext;   } }"
---

https://stackoverflow.com/q/992019

I need to implement 256 bit AES encryption, but all the examples I have found online use a &quot;KeyGenerator&quot; to generate a 256 bit key, but I would like to use my own passkey. How can I create my own key? I have tried padding it out to 256 bits, but then I get an error saying that the key is too long. I do have the unlimited jurisdiction patch installed, so thats not the problem :)
Ie. The KeyGenerator looks like this ...
Code taken from here
EDIT
I was actually padding the password out to 256 bytes, not bits, which is too long. The following is some code I am using now that I have some more experience with this.
The &quot;TODO&quot; bits you need to do yourself :-)


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
// Get the KeyGenerator
KeyGenerator kgen = KeyGenerator.getInstance("AES");
kgen.init(128); // 192 and 256 bits may not be available

// Generate the secret key specs.
SecretKey skey = kgen.generateKey();
byte[] raw = skey.getEncoded();
byte[] key = null; // TODO
byte[] input = null; // TODO
byte[] output = null;
SecretKeySpec keySpec = null;
keySpec = new SecretKeySpec(key, "AES");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding");
cipher.init(Cipher.ENCRYPT_MODE, keySpec);
output = cipher.doFinal(input)
```


## Original code snippet

https://stackoverflow.com/a/992413

Share the password (a char[]) and salt (a byte[]—8 bytes selected by a SecureRandom makes a good salt—which doesn&#x27;t need to be kept secret) with the recipient out-of-band. Then to derive a good key from this information:
The magic numbers (which could be defined as constants somewhere) 65536 and 256 are the key derivation iteration count and the key size, respectively.
The key derivation function is iterated to require significant computational effort, and that prevents attackers from quickly trying many different passwords. The iteration count can be changed depending on the computing resources available.
The key size can be reduced to 128 bits, which is still considered &quot;strong&quot; encryption, but it doesn&#x27;t give much of a safety margin if attacks are discovered that weaken AES.
Used with a proper block-chaining mode, the same derived key can be used to encrypt many messages. In CBC, a random initialization vector (IV) is generated for each message, yielding different cipher text even if the plain text is identical. CBC may not be the most secure mode available to you (see AEAD below); there are many other modes with different security properties, but they all use a similar random input. In any case, the outputs of each encryption operation are the cipher text and the initialization vector:
Store the ciphertext and the iv. On decryption, the SecretKey is regenerated in exactly the same way, using using the password with the same salt and iteration parameters. Initialize the cipher with this key and the initialization vector stored with the message:
Java 7 included API support for AEAD cipher modes, and the &quot;SunJCE&quot; provider included with OpenJDK and Oracle distributions implements these beginning with Java 8. One of these modes is strongly recommended in place of CBC; it will protect the integrity of the data as well as their privacy.
A java.security.InvalidKeyException with the message &quot;Illegal key size or default parameters&quot; means that the cryptography strength is limited; the unlimited strength jurisdiction policy files are not in the correct location. In a JDK, they should be placed under ${jdk}/jre/lib/security
Based on the problem description, it sounds like the policy files are not correctly installed. Systems can easily have multiple Java runtimes; double-check to make sure that the correct location is being used.

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
/* Derive the key, given password and salt. */
SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
SecretKey tmp = factory.generateSecret(spec);
SecretKey secret = new SecretKeySpec(tmp.getEncoded(), "AES");
/* Encrypt the message. */
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
cipher.init(Cipher.ENCRYPT_MODE, secret);
AlgorithmParameters params = cipher.getParameters();
byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
byte[] ciphertext = cipher.doFinal("Hello, World!".getBytes("UTF-8"));
/* Decrypt the message, given derived key and initialization vector. */
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
String plaintext = new String(cipher.doFinal(ciphertext), "UTF-8");
System.out.println(plaintext);
```

## Produced APIzation

[`APIzator992413.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator992413.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import java.security.AlgorithmParameters;
import java.security.spec.KeySpec;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Java 256-bit AES Password-Based Encryption
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/992413">https://stackoverflow.com/a/992413</a>
 */
public class APIzator992413 {

  public static String encryption() throws RuntimeException {
    /* Derive the key, given password and salt. */
    SecretKeyFactory factory = SecretKeyFactory.getInstance(
      "PBKDF2WithHmacSHA256"
    );
    KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), "AES");
    /* Encrypt the message. */
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
    byte[] ciphertext = cipher.doFinal("Hello, World!".getBytes("UTF-8"));
    /* Decrypt the message, given derived key and initialization vector. */
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
    String plaintext = new String(cipher.doFinal(ciphertext), "UTF-8");
    return plaintext;
  }
}

```