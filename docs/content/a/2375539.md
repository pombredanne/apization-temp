---
title: "[Q#2375222][A#2375539] Java SimpleDateFormat for time zone with a colon separator?"
question_title: "Java SimpleDateFormat for time zone with a colon separator?"
question_text: "I have a date in the following format: 2010-03-01T00:00:00-08:00 I have thrown the following SimpleDateFormats at it to parse it: I have a convenience method that uses those formats like so: It seems to hit on the pattern yyyyMMddHHmm but returns the date as Thu Dec 03 00:01:00 PST 2009. What is the correct pattern to parse this date? UPDATE: I don't NEED the time zone parsing. I don't anticipate having time sensitive issues moving between zones, but how would I get the \"-08:00\" zone format to parse???? Unit test: Output from unit test:"
answer_text: "JodaTime's DateTimeFormat to rescue: (time and timezone difference in toString() is just because I'm at GMT-4 and didn't set locale explicitly) If you want to end up with java.util.Date just use DateTime#toDate(): Wait for JDK7 (JSR-310) JSR-310, the referrence implementation is called ThreeTen (hopefully it will make it into Java 8) if you want a better formatter in the standard Java SE API. The current SimpleDateFormat indeed doesn't eat the colon in the timezone notation. Update: as per the update, you apparently don't need the timezone. This should work with SimpleDateFormat. Just omit it (the Z) in the pattern. (which is correct as per my timezone)"
apization_code: "package com.stackoverflow.api;  import com.google.appengine.repackaged.com.google.api.client.util.DateTime; import com.google.appengine.repackaged.com.google.type.proto1api.Date; import com.google.appengine.repackaged.org.joda.time.format.DateTimeFormat; import com.google.appengine.repackaged.org.joda.time.format.DateTimeFormatter;  /**  * Java SimpleDateFormat for time zone with a colon separator?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/2375539\">https://stackoverflow.com/a/2375539</a>  */ public class APIzator2375539 {    public static Date simpledateformat(String dateString, String pattern)     throws RuntimeException {     DateTimeFormatter dtf = DateTimeFormat.forPattern(pattern);     DateTime dateTime = dtf.parseDateTime(dateString);     // 2010-03-01T04:00:00.000-04:00     System.out.println(dateTime);     return dateTime.toDate();   } }"
---

https://stackoverflow.com/q/2375222

I have a date in the following format: 2010-03-01T00:00:00-08:00
I have thrown the following SimpleDateFormats at it to parse it:
I have a convenience method that uses those formats like so:
It seems to hit on the pattern yyyyMMddHHmm but returns the date as Thu Dec 03 00:01:00 PST 2009.
What is the correct pattern to parse this date?
UPDATE: I don&#x27;t NEED the time zone parsing. I don&#x27;t anticipate having time sensitive issues moving between zones, but how would I get the &quot;-08:00&quot; zone format to parse????
Unit test:
Output from unit test:


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
private static final SimpleDateFormat[] FORMATS = {
        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ"), //ISO8601 long RFC822 zone
        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssz"), //ISO8601 long long form zone
        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"), //ignore timezone
        new SimpleDateFormat("yyyyMMddHHmmssZ"), //ISO8601 short
        new SimpleDateFormat("yyyyMMddHHmm"),
        new SimpleDateFormat("yyyyMMdd"), //birthdate from NIST IHE C32 sample
        new SimpleDateFormat("yyyyMM"),
        new SimpleDateFormat("yyyy") //just the year
    };
public static Date figureOutTheDamnDate(String wtf) {
    if (wtf == null) {
        return null;
    }
    Date retval = null;
    for (SimpleDateFormat sdf : FORMATS) {
        try {
            sdf.setLenient(false)
            retval = sdf.parse(wtf);
            System.out.println("Date:" + wtf + " hit on pattern:" + sdf.toPattern());
            break;
        } catch (ParseException ex) {
            retval = null;
            continue;
        }
    }

    return retval;
}
@Test
public void test_date_parser() {
    System.out.println("\ntest_date_parser");
    //month is zero based, are you effing kidding me
    Calendar d = new GregorianCalendar(2000, 3, 6, 13, 00, 00);
    assertEquals(d.getTime(), MyClass.figureOutTheDamnDate("200004061300"));
    assertEquals(new GregorianCalendar(1950, 0, 1).getTime(), MyClass.figureOutTheDamnDate("1950"));
    assertEquals(new GregorianCalendar(1997, 0, 1).getTime(),  MyClass.figureOutTheDamnDate("199701"));
    assertEquals(new GregorianCalendar(2010, 1, 25, 15, 19, 44).getTime(),   MyClass.figureOutTheDamnDate("20100225151944-0800"));

    //my machine happens to be in GMT-0800
    assertEquals(new GregorianCalendar(2010, 1, 15, 13, 15, 00).getTime(),MyClass.figureOutTheDamnDate("2010-02-15T13:15:00-05:00"));
    assertEquals(new GregorianCalendar(2010, 1, 15, 18, 15, 00).getTime(), MyClass.figureOutTheDamnDate("2010-02-15T18:15:00-05:00"));

    assertEquals(new GregorianCalendar(2010, 2, 1).getTime(), MyClass.figureOutTheDamnDate("2010-03-01T00:00:00-08:00"));
    assertEquals(new GregorianCalendar(2010, 2, 1, 17, 0, 0).getTime(), MyClass.figureOutTheDamnDate("2010-03-01T17:00:00-05:00"));
}
test_date_parser
Date:200004061300 hit on pattern:yyyyMMddHHmm
Date:1950 hit on pattern:yyyy
Date:199701 hit on pattern:yyyyMM
Date:20100225151944-0800 hit on pattern:yyyyMMddHHmmssZ
Date:2010-02-15T13:15:00-05:00 hit on pattern:yyyy-MM-dd'T'HH:mm:ss
Date:2010-02-15T18:15:00-05:00 hit on pattern:yyyy-MM-dd'T'HH:mm:ss
Date:2010-03-01T00:00:00-08:00 hit on pattern:yyyy-MM-dd'T'HH:mm:ss
Date:2010-03-01T17:00:00-05:00 hit on pattern:yyyy-MM-dd'T'HH:mm:ss
```


## Original code snippet

https://stackoverflow.com/a/2375539

JodaTime&#x27;s DateTimeFormat to rescue:
(time and timezone difference in toString() is just because I&#x27;m at GMT-4 and didn&#x27;t set locale explicitly)
If you want to end up with java.util.Date just use DateTime#toDate():
Wait for JDK7 (JSR-310) JSR-310, the referrence implementation is called ThreeTen (hopefully it will make it into Java 8) if you want a better formatter in the standard Java SE API. The current SimpleDateFormat indeed doesn&#x27;t eat the colon in the timezone notation.
Update: as per the update, you apparently don&#x27;t need the timezone. This should work with SimpleDateFormat. Just omit it (the Z) in the pattern.
(which is correct as per my timezone)

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
String dateString = "2010-03-01T00:00:00-08:00";
String pattern = "yyyy-MM-dd'T'HH:mm:ssZ";
DateTimeFormatter dtf = DateTimeFormat.forPattern(pattern);
DateTime dateTime = dtf.parseDateTime(dateString);
System.out.println(dateTime); // 2010-03-01T04:00:00.000-04:00
Date date = dateTime.toDate();
String dateString = "2010-03-01T00:00:00-08:00";
String pattern = "yyyy-MM-dd'T'HH:mm:ss";
SimpleDateFormat sdf = new SimpleDateFormat(pattern);
Date date = sdf.parse(dateString);
System.out.println(date); // Mon Mar 01 00:00:00 BOT 2010
```

## Produced APIzation

[`APIzator2375539.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator2375539.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import com.google.appengine.repackaged.com.google.api.client.util.DateTime;
import com.google.appengine.repackaged.com.google.type.proto1api.Date;
import com.google.appengine.repackaged.org.joda.time.format.DateTimeFormat;
import com.google.appengine.repackaged.org.joda.time.format.DateTimeFormatter;

/**
 * Java SimpleDateFormat for time zone with a colon separator?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/2375539">https://stackoverflow.com/a/2375539</a>
 */
public class APIzator2375539 {

  public static Date simpledateformat(String dateString, String pattern)
    throws RuntimeException {
    DateTimeFormatter dtf = DateTimeFormat.forPattern(pattern);
    DateTime dateTime = dtf.parseDateTime(dateString);
    // 2010-03-01T04:00:00.000-04:00
    System.out.println(dateTime);
    return dateTime.toDate();
  }
}

```