---
title: "[Q#1299837][A#1299889] Cannot refer to a non-final variable inside an inner class defined in a different method"
question_title: "Cannot refer to a non-final variable inside an inner class defined in a different method"
question_text: "Edited: I need to change the values of several variables as they run several times thorugh a timer. I need to keep updating the values with every iteration through the timer. I cannot set the values to final as that will prevent me from updating the values however I am getting the error I describe in the initial question below: I had previously written what is below: I am getting the error \"cannot refer to a non-final variable inside an inner class defined in a different method\". This is happening for the double called price and the Price called priceObject. Do you know why I get this problem. I do not understand why I need to have a final declaration. Also if you can see what it is I am trying to do, what do I have to do to get around this problem."
answer_text: "Java doesn't support true closures, even though using an anonymous class like you are using here (new TimerTask() { ... }) looks like a kind of closure. edit - See the comments below - the following is not a correct explanation, as KeeperOfTheSoul points out. This is why it doesn't work: The variables lastPrice and price are local variables in the main() method. The object that you create with the anonymous class might last until after the main() method returns. When the main() method returns, local variables (such as lastPrice and price) will be cleaned up from the stack, so they won't exist anymore after main() returns. But the anonymous class object references these variables. Things would go horribly wrong if the anonymous class object tries to access the variables after they have been cleaned up. By making lastPrice and price final, they are not really variables anymore, but constants. The compiler can then just replace the use of lastPrice and price in the anonymous class with the values of the constants (at compile time, of course), and you won't have the problem with accessing non-existent variables anymore. Other programming languages that do support closures do it by treating those variables specially - by making sure they don't get destroyed when the method ends, so that the closure can still access the variables. @Ankur: You could do this:"
apization_code: "package com.stackoverflow.api;  import io.netty.util.Timer; import io.netty.util.TimerTask;  /**  * Cannot refer to a non-final variable inside an inner class defined in a different method  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/1299889\">https://stackoverflow.com/a/1299889</a>  */ public class APIzator1299889 {    public static void refer(int period, int delay) {     Timer timer = new Timer();     timer.scheduleAtFixedRate(       new TimerTask() {         // Variables as member variables instead of local variables in main()         private double lastPrice = 0;          private Price priceObject = new Price();          private double price = 0;          public void run() {           price = priceObject.getNextPrice(lastPrice);           System.out.println();           lastPrice = price;         }       },       delay,       period     );   } }"
---

https://stackoverflow.com/q/1299837

Edited:
I need to change the values of several variables as they run several times thorugh a timer. I need to keep updating the values with every iteration through the timer. I cannot set the values to final as that will prevent me from updating the values however I am getting the error I describe in the initial question below:
I had previously written what is below:
I am getting the error &quot;cannot refer to a non-final variable inside an inner class defined in a different method&quot;.
This is happening for the double called price and the Price called priceObject. Do you know why I get this problem. I do not understand why I need to have a final declaration. Also if you can see what it is I am trying to do, what do I have to do to get around this problem.


```java
public static void main(String args[]) {

    int period = 2000;
    int delay = 2000;

    double lastPrice = 0;
    Price priceObject = new Price();
    double price = 0;

    Timer timer = new Timer();

    timer.scheduleAtFixedRate(new TimerTask() {
        public void run() {
            price = priceObject.getNextPrice(lastPrice);
            System.out.println();
            lastPrice = price;
        }
    }, delay, period);
}
```


## Original code snippet

https://stackoverflow.com/a/1299889

Java doesn&#x27;t support true closures, even though using an anonymous class like you are using here (new TimerTask() { ... }) looks like a kind of closure.
edit - See the comments below - the following is not a correct explanation, as KeeperOfTheSoul points out.
This is why it doesn&#x27;t work:
The variables lastPrice and price are local variables in the main() method. The object that you create with the anonymous class might last until after the main() method returns.
When the main() method returns, local variables (such as lastPrice and price) will be cleaned up from the stack, so they won&#x27;t exist anymore after main() returns.
But the anonymous class object references these variables. Things would go horribly wrong if the anonymous class object tries to access the variables after they have been cleaned up.
By making lastPrice and price final, they are not really variables anymore, but constants. The compiler can then just replace the use of lastPrice and price in the anonymous class with the values of the constants (at compile time, of course), and you won&#x27;t have the problem with accessing non-existent variables anymore.
Other programming languages that do support closures do it by treating those variables specially - by making sure they don&#x27;t get destroyed when the method ends, so that the closure can still access the variables.
@Ankur: You could do this:

```java
public static void main(String args[]) {
    int period = 2000;
    int delay = 2000;

    Timer timer = new Timer();

    timer.scheduleAtFixedRate(new TimerTask() {
        // Variables as member variables instead of local variables in main()
        private double lastPrice = 0;
        private Price priceObject = new Price();
        private double price = 0;

        public void run() {
            price = priceObject.getNextPrice(lastPrice);
            System.out.println();
            lastPrice = price;
        }
    }, delay, period);      
}
```

## Produced APIzation

[`APIzator1299889.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator1299889.java)

```java
package com.stackoverflow.api;

import io.netty.util.Timer;
import io.netty.util.TimerTask;

/**
 * Cannot refer to a non-final variable inside an inner class defined in a different method
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/1299889">https://stackoverflow.com/a/1299889</a>
 */
public class APIzator1299889 {

  public static void refer(int period, int delay) {
    Timer timer = new Timer();
    timer.scheduleAtFixedRate(
      new TimerTask() {
        // Variables as member variables instead of local variables in main()
        private double lastPrice = 0;

        private Price priceObject = new Price();

        private double price = 0;

        public void run() {
          price = priceObject.getNextPrice(lastPrice);
          System.out.println();
          lastPrice = price;
        }
      },
      delay,
      period
    );
  }
}

```