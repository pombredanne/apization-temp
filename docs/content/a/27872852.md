---
title: "[Q#23699371][A#27872852] Java 8 Distinct by property"
question_title: "Java 8 Distinct by property"
question_text: "In Java 8 how can I filter a collection using the Stream API by checking the distinctness of a property of each object? For example I have a list of Person object and I want to remove people with the same name, Will use the default equality check for a Person object, so I need something like, Unfortunately the distinct() method has no such overload. Without modifying the equality check inside the Person class is it possible to do this succinctly?"
answer_text: "Consider distinct to be a stateful filter. Here is a function that returns a predicate that maintains state about what it's seen previously, and that returns whether the given element was seen for the first time: Then you can write: Note that if the stream is ordered and is run in parallel, this will preserve an arbitrary element from among the duplicates, instead of the first one, as distinct() does. (This is essentially the same as my answer to this question: Java Lambda Stream Distinct() on arbitrary key?)"
apization_code: "package com.stackoverflow.api;  import EDU.oswego.cs.dl.util.concurrent.ConcurrentHashMap; import avro.shaded.com.google.common.base.Function; import avro.shaded.com.google.common.base.Predicate; import com.gargoylesoftware.htmlunit.javascript.host.Set;  /**  * Java 8 Distinct by property  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/27872852\">https://stackoverflow.com/a/27872852</a>  */ public class APIzator27872852 {    public static <T> Predicate<T> distinctByKey(     Function<? super T, ?> keyExtractor   ) {     Set<Object> seen = ConcurrentHashMap.newKeySet();     return t -> seen.add(keyExtractor.apply(t));   } }"
---

https://stackoverflow.com/q/23699371

In Java 8 how can I filter a collection using the Stream API by checking the distinctness of a property of each object?
For example I have a list of Person object and I want to remove people with the same name,
Will use the default equality check for a Person object, so I need something like,
Unfortunately the distinct() method has no such overload. Without modifying the equality check inside the Person class is it possible to do this succinctly?


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
persons.stream().distinct();
persons.stream().distinct(p -> p.getName());
```


## Original code snippet

https://stackoverflow.com/a/27872852

Consider distinct to be a stateful filter. Here is a function that returns a predicate that maintains state about what it&#x27;s seen previously, and that returns whether the given element was seen for the first time:
Then you can write:
Note that if the stream is ordered and is run in parallel, this will preserve an arbitrary element from among the duplicates, instead of the first one, as distinct() does.
(This is essentially the same as my answer to this question: Java Lambda Stream Distinct() on arbitrary key?)

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
    Set<Object> seen = ConcurrentHashMap.newKeySet();
    return t -> seen.add(keyExtractor.apply(t));
}
persons.stream().filter(distinctByKey(Person::getName))
```

## Produced APIzation

[`APIzator27872852.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator27872852.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import EDU.oswego.cs.dl.util.concurrent.ConcurrentHashMap;
import avro.shaded.com.google.common.base.Function;
import avro.shaded.com.google.common.base.Predicate;
import com.gargoylesoftware.htmlunit.javascript.host.Set;

/**
 * Java 8 Distinct by property
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/27872852">https://stackoverflow.com/a/27872852</a>
 */
public class APIzator27872852 {

  public static <T> Predicate<T> distinctByKey(
    Function<? super T, ?> keyExtractor
  ) {
    Set<Object> seen = ConcurrentHashMap.newKeySet();
    return t -> seen.add(keyExtractor.apply(t));
  }
}

```