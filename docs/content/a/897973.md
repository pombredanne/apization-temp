---
title: "[Q#897935][A#897973] When do Java generics require <? extends T> instead of <T> and is there any downside of switching?"
question_title: "When do Java generics require <? extends T> instead of <T> and is there any downside of switching?"
question_text: "Given the following example (using JUnit with Hamcrest matchers): This does not compile with the JUnit assertThat method signature of: The compiler error message is: However, if I change the assertThat method signature to: Then the compilation works. So three questions: For reference, here is the JUnit implementation of assertThat:"
answer_text: "First - I have to direct you to http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html -- she does an amazing job. The basic idea is that you use when the actual parameter can be SomeClass or any subtype of it. In your example, You're saying that expected can contain Class objects that represent any class that implements Serializable. Your result map says it can only hold Date class objects. When you pass in result, you're setting T to exactly Map of String to Date class objects, which doesn't match Map of String to anything that's Serializable. One thing to check -- are you sure you want Class<Date> and not Date? A map of String to Class<Date> doesn't sound terribly useful in general (all it can hold is Date.class as values rather than instances of Date) As for genericizing assertThat, the idea is that the method can ensure that a Matcher that fits the result type is passed in."
apization_code: "package com.stackoverflow.api;  import com.gargoylesoftware.htmlunit.javascript.host.Map; import java.io.Serializable;  /**  * When do Java generics require <? extends T> instead of <T> and is there any downside of switching?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/897973\">https://stackoverflow.com/a/897973</a>  */ public class APIzator897973 {    public static void require(     Map<String, Class<? extends Serializable>> expected,     Map<String, Class<java.util.Date>> result   )     throws RuntimeException {     assertThat(result, is(expected));   } }"
---

https://stackoverflow.com/q/897935

Given the following example (using JUnit with Hamcrest matchers):
This does not compile with the JUnit assertThat method signature of:
The compiler error message is:
However, if I change the assertThat method signature to:
Then the compilation works.
So three questions:
For reference, here is the JUnit implementation of assertThat:


```java
Map<String, Class<? extends Serializable>> expected = null;
Map<String, Class<java.util.Date>> result = null;
assertThat(result, is(expected));
public static <T> void assertThat(T actual, Matcher<T> matcher)
Error:Error:line (102)cannot find symbol method
assertThat(java.util.Map<java.lang.String,java.lang.Class<java.util.Date>>,
org.hamcrest.Matcher<java.util.Map<java.lang.String,java.lang.Class
    <? extends java.io.Serializable>>>)
public static <T> void assertThat(T result, Matcher<? extends T> matcher)
public static <T> void assertThat(T actual, Matcher<T> matcher) {
    assertThat("", actual, matcher);
}

public static <T> void assertThat(String reason, T actual, Matcher<T> matcher) {
    if (!matcher.matches(actual)) {
        Description description = new StringDescription();
        description.appendText(reason);
        description.appendText("\nExpected: ");
        matcher.describeTo(description);
        description
            .appendText("\n     got: ")
            .appendValue(actual)
            .appendText("\n");

        throw new java.lang.AssertionError(description.toString());
    }
}
```


## Original code snippet

https://stackoverflow.com/a/897973

First - I have to direct you to http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html -- she does an amazing job.
The basic idea is that you use
when the actual parameter can be SomeClass or any subtype of it.
In your example,
You&#x27;re saying that expected can contain Class objects that represent any class that implements Serializable. Your result map says it can only hold Date class objects.
When you pass in result, you&#x27;re setting T to exactly Map of String to Date class objects, which doesn&#x27;t match Map of String to anything that&#x27;s Serializable.
One thing to check -- are you sure you want Class&lt;Date&gt; and not Date? A map of String to Class&lt;Date&gt; doesn&#x27;t sound terribly useful in general (all it can hold is Date.class as values rather than instances of Date)
As for genericizing assertThat, the idea is that the method can ensure that a Matcher that fits the result type is passed in.

```java
<T extends SomeClass>
Map<String, Class<? extends Serializable>> expected = null;
Map<String, Class<java.util.Date>> result = null;
assertThat(result, is(expected));
```

## Produced APIzation

[`APIzator897973.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator897973.java)

```java
package com.stackoverflow.api;

import com.gargoylesoftware.htmlunit.javascript.host.Map;
import java.io.Serializable;

/**
 * When do Java generics require <? extends T> instead of <T> and is there any downside of switching?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/897973">https://stackoverflow.com/a/897973</a>
 */
public class APIzator897973 {

  public static void require(
    Map<String, Class<? extends Serializable>> expected,
    Map<String, Class<java.util.Date>> result
  )
    throws RuntimeException {
    assertThat(result, is(expected));
  }
}

```