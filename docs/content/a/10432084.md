---
title: "[Q#10431981][A#10432084] Remove elements from collection while iterating"
question_title: "Remove elements from collection while iterating"
question_text: "AFAIK, there are two approaches: For instance, and Are there any reasons to prefer one approach over the other (e.g. preferring the first approach for the simple reason of readability)?"
answer_text: "Let me give a few examples with some alternatives to avoid a ConcurrentModificationException. Suppose we have the following collection of books Collect and Remove The first technique consists in collecting all the objects that we want to delete (e.g. using an enhanced for loop) and after we finish iterating, we remove all found objects. This is supposing that the operation you want to do is \"delete\". If you want to \"add\" this approach would also work, but I would assume you would iterate over a different collection to determine what elements you want to add to a second collection and then issue an addAll method at the end. Using ListIterator If you are working with lists, another technique consists in using a ListIterator which has support for removal and addition of items during the iteration itself. Again, I used the \"remove\" method in the example above which is what your question seemed to imply, but you may also use its add method to add new elements during iteration. Using JDK 8 For those working with Java 8 or superior versions, there are a couple of other techniques you could use to take advantage of it. You could use the new removeIf method in the Collection base class: Or use the new stream API: In this last case, to filter elements out of a collection, you reassign the original reference to the filtered collection (i.e. books = filtered) or used the filtered collection to removeAll the found elements from the original collection (i.e. books.removeAll(filtered)). Use Sublist or Subset There are other alternatives as well. If the list is sorted, and you want to remove consecutive elements you can create a sublist and then clear it: Since the sublist is backed by the original list this would be an efficient way of removing this subcollection of elements. Something similar could be achieved with sorted sets using NavigableSet.subSet method, or any of the slicing methods offered there. Considerations: What method you use might depend on what you are intending to do"
apization_code: "package com.stackoverflow.api;  import java.awt.print.Book; import java.util.ArrayList; import java.util.List; import java.util.ListIterator; import java.util.stream.Collectors;  /**  * Remove elements from collection while iterating  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/10432084\">https://stackoverflow.com/a/10432084</a>  */ public class APIzator10432084 {    public static void element(List<Book> books) throws RuntimeException {     ISBN isbn = new ISBN(\"0-201-63361-2\");     List<Book> found = new ArrayList<Book>();     for (Book book : books) {       if (book.getIsbn().equals(isbn)) {         found.add(book);       }     }     books.removeAll(found);     ListIterator<Book> iter = books.listIterator();     while (iter.hasNext()) {       if (iter.next().getIsbn().equals(isbn)) {         iter.remove();       }     }     ISBN other = new ISBN(\"0-201-63361-2\");     books.removeIf(b -> b.getIsbn().equals(other));     ISBN other = new ISBN(\"0-201-63361-2\");     List<Book> filtered = books       .stream()       .filter(b -> b.getIsbn().equals(other))       .collect(Collectors.toList());     books.subList(0, 5).clear();   } }"
---

https://stackoverflow.com/q/10431981

AFAIK, there are two approaches:
For instance,
and
Are there any reasons to prefer one approach over the other (e.g. preferring the first approach for the simple reason of readability)?


```java
List<Foo> fooListCopy = new ArrayList<Foo>(fooList);
for(Foo foo : fooListCopy){
    // modify actual fooList
}
Iterator<Foo> itr = fooList.iterator();
while(itr.hasNext()){
    // modify actual fooList using itr.remove()
}
```


## Original code snippet

https://stackoverflow.com/a/10432084

Let me give a few examples with some alternatives to avoid a ConcurrentModificationException.
Suppose we have the following collection of books
Collect and Remove
The first technique consists in collecting all the objects that we want to delete (e.g. using an enhanced for loop) and after we finish iterating, we remove all found objects.
This is supposing that the operation you want to do is &quot;delete&quot;.
If you want to &quot;add&quot; this approach would also work, but I would assume you would iterate over a different collection to determine what elements you want to add to a second collection and then issue an addAll method at the end.
Using ListIterator
If you are working with lists, another technique consists in using a ListIterator which has support for removal and addition of items during the iteration itself.
Again, I used the &quot;remove&quot; method in the example above which is what your question seemed to imply, but you may also use its add method to add new elements during iteration.
Using JDK 8
For those working with Java 8 or superior versions, there are a couple of other techniques you could use to take advantage of it.
You could use the new removeIf method in the Collection base class:
Or use the new stream API:
In this last case, to filter elements out of a collection, you reassign the original reference to the filtered collection (i.e. books = filtered) or used the filtered collection to removeAll the found elements from the original collection (i.e. books.removeAll(filtered)).
Use Sublist or Subset
There are other alternatives as well. If the list is sorted, and you want to remove consecutive elements you can create a sublist and then clear it:
Since the sublist is backed by the original list this would be an efficient way of removing this subcollection of elements.
Something similar could be achieved with sorted sets using NavigableSet.subSet method, or any of the slicing methods offered there.
Considerations:
What method you use might depend on what you are intending to do

```java
List<Book> books = new ArrayList<Book>();
books.add(new Book(new ISBN("0-201-63361-2")));
books.add(new Book(new ISBN("0-201-63361-3")));
books.add(new Book(new ISBN("0-201-63361-4")));
ISBN isbn = new ISBN("0-201-63361-2");
List<Book> found = new ArrayList<Book>();
for(Book book : books){
    if(book.getIsbn().equals(isbn)){
        found.add(book);
    }
}
books.removeAll(found);
ListIterator<Book> iter = books.listIterator();
while(iter.hasNext()){
    if(iter.next().getIsbn().equals(isbn)){
        iter.remove();
    }
}
ISBN other = new ISBN("0-201-63361-2");
books.removeIf(b -> b.getIsbn().equals(other));
ISBN other = new ISBN("0-201-63361-2");
List<Book> filtered = books.stream()
                           .filter(b -> b.getIsbn().equals(other))
                           .collect(Collectors.toList());
books.subList(0,5).clear();
```

## Produced APIzation

[`APIzator10432084.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator10432084.java)

```java
package com.stackoverflow.api;

import java.awt.print.Book;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.stream.Collectors;

/**
 * Remove elements from collection while iterating
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/10432084">https://stackoverflow.com/a/10432084</a>
 */
public class APIzator10432084 {

  public static void element(List<Book> books) throws RuntimeException {
    ISBN isbn = new ISBN("0-201-63361-2");
    List<Book> found = new ArrayList<Book>();
    for (Book book : books) {
      if (book.getIsbn().equals(isbn)) {
        found.add(book);
      }
    }
    books.removeAll(found);
    ListIterator<Book> iter = books.listIterator();
    while (iter.hasNext()) {
      if (iter.next().getIsbn().equals(isbn)) {
        iter.remove();
      }
    }
    ISBN other = new ISBN("0-201-63361-2");
    books.removeIf(b -> b.getIsbn().equals(other));
    ISBN other = new ISBN("0-201-63361-2");
    List<Book> filtered = books
      .stream()
      .filter(b -> b.getIsbn().equals(other))
      .collect(Collectors.toList());
    books.subList(0, 5).clear();
  }
}

```