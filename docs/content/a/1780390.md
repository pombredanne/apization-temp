---
title: "[Q#1780385][A#1780390] java: HashMap<String, int> not working"
question_title: "java: HashMap<String, int> not working"
question_text: "HashMap<String, int> doesn't seem to work but HashMap<String, Integer> does work. Any ideas why?"
answer_text: "You can't use primitive types as generic arguments in Java. Use instead: With auto-boxing/unboxing there is little difference in the code. Auto-boxing means you can write: instead of: Auto-boxing means the first version is implicitly converted to the second. Auto-unboxing means you can write: instead of: The implicit call to intValue() means if the key isn't found it will generate a NullPointerException, for example: The reason is type erasure. Unlike, say, in C# generic types aren't retained at runtime. They are just \"syntactic sugar\" for explicit casting to save you doing this: To give you an example, this code is perfectly legal:"
apization_code: "package com.stackoverflow.api;  import java.util.HashMap; import java.util.Map;  /**  * java: HashMap<String, int> not working  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/1780390\">https://stackoverflow.com/a/1780390</a>  */ public class APIzator1780390 {    public static void java(Map<String, Integer> myMap) throws RuntimeException {     int i = myMap.get(\"foo\");     int i = myMap.get(\"foo\").intValue();     // NullPointerException     int i = myMap.get(\"bar\");     Integer i = (Integer) myMap.get(\"foo\");     Map<String, Integer> myMap = new HashMap<String, Integer>();     Map<Integer, String> map2 = (Map<Integer, String>) myMap;     map2.put(3, \"foo\");   } }"
---

https://stackoverflow.com/q/1780385

HashMap&lt;String, int&gt; doesn&#x27;t seem to work but HashMap&lt;String, Integer&gt; does work.
Any ideas why?



## Original code snippet

https://stackoverflow.com/a/1780390

You can&#x27;t use primitive types as generic arguments in Java. Use instead:
With auto-boxing/unboxing there is little difference in the code. Auto-boxing means you can write:
instead of:
Auto-boxing means the first version is implicitly converted to the second. Auto-unboxing means you can write:
instead of:
The implicit call to intValue() means if the key isn&#x27;t found it will generate a NullPointerException, for example:
The reason is type erasure. Unlike, say, in C# generic types aren&#x27;t retained at runtime. They are just &quot;syntactic sugar&quot; for explicit casting to save you doing this:
To give you an example, this code is perfectly legal:

```java
Map<String, Integer> myMap = new HashMap<String, Integer>();
myMap.put("foo", 3);
myMap.put("foo", new Integer(3));
int i = myMap.get("foo");
int i = myMap.get("foo").intValue();
int i = myMap.get("bar"); // NullPointerException
Integer i = (Integer)myMap.get("foo");
Map<String, Integer> myMap = new HashMap<String, Integer>();
Map<Integer, String> map2 = (Map<Integer, String>)myMap;
map2.put(3, "foo");
```

## Produced APIzation

[`APIzator1780390.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator1780390.java)

```java
package com.stackoverflow.api;

import java.util.HashMap;
import java.util.Map;

/**
 * java: HashMap<String, int> not working
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/1780390">https://stackoverflow.com/a/1780390</a>
 */
public class APIzator1780390 {

  public static void java(Map<String, Integer> myMap) throws RuntimeException {
    int i = myMap.get("foo");
    int i = myMap.get("foo").intValue();
    // NullPointerException
    int i = myMap.get("bar");
    Integer i = (Integer) myMap.get("foo");
    Map<String, Integer> myMap = new HashMap<String, Integer>();
    Map<Integer, String> map2 = (Map<Integer, String>) myMap;
    map2.put(3, "foo");
  }
}

```