---
title: "[Q#23414090][A#23414798] What is the difference between up-casting and down-casting with respect to class variable"
question_title: "What is the difference between up-casting and down-casting with respect to class variable"
question_text: "What is the difference between up-casting and down-casting with respect to class variable? For example in the following program class Animal contains only one method but Dog class              contains two methods, then how we cast the Dog variable to the Animal Variable. If casting is done then how can we call the Dog's another method with Animal's variable."
answer_text: "Upcasting is casting to a supertype, while downcasting is casting to a subtype. Upcasting is always allowed, but downcasting involves a type check and can throw a ClassCastException. In your case, a cast from from Dog to an Animal is an upcast, because a Dog is-a Animal. In general, you can upcast whenever there is an is-a relationship between two classes. Downcasting would be something like this: Basically what you're doing is telling the compiler that you know what the runtime type of the object really is. The compiler will allow the conversion, but will still insert a runtime sanity check to make sure that the conversion makes sense. In this case, the cast is possible because at runtime animal is actually a Dog even though the static type of animal is Animal. However, if you were to do this: You'd get a ClassCastException. The reason why is because animal's runtime type is Animal, and so when you tell the runtime to perform the cast it sees that animal isn't really a Dog and so throws a ClassCastException. To call a superclass's method you can do super.method() or by performing the upcast. To call a subclass's method you have to do a downcast. As shown above, you normally risk a ClassCastException by doing this; however, you can use the instanceof operator to check the runtime type of the object before performing the cast, which allows you to prevent ClassCastExceptions:"
apization_code: "package com.stackoverflow.api;  /**  * What is the difference between up-casting and down-casting with respect to class variable  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/23414798\">https://stackoverflow.com/a/23414798</a>  */ public class APIzator23414798 {    public static void be() throws RuntimeException {     Animal animal = new Dog();     Dog castedDog = (Dog) animal;     Animal animal = new Animal();     Dog notADog = (Dog) animal;     // Maybe a Dog? Maybe a Cat? Maybe an Animal?     Animal animal = getAnimal();     if (animal instanceof Dog) {       // Guaranteed to succeed, barring classloader shenanigans       Dog castedDog = (Dog) animal;     }   } }"
---

https://stackoverflow.com/q/23414090

What is the difference between up-casting and down-casting with respect to class variable?
For example in the following program class Animal contains only one method but Dog class              contains two methods, then how we cast the Dog variable to the Animal Variable.
If casting is done then how can we call the Dog&#x27;s another method with Animal&#x27;s variable.


```java
class Animal 
{ 
    public void callme()
    {
        System.out.println("In callme of Animal");
    }
}


class Dog extends Animal 
{ 
    public void callme()
    {
        System.out.println("In callme of Dog");
    }

    public void callme2()
    {
        System.out.println("In callme2 of Dog");
    }
}

public class UseAnimlas 
{
    public static void main (String [] args) 
    {
        Dog d = new Dog();      
        Animal a = (Animal)d;
        d.callme();
        a.callme();
        ((Dog) a).callme2();
    }
}
```


## Original code snippet

https://stackoverflow.com/a/23414798

Upcasting is casting to a supertype, while downcasting is casting to a subtype. Upcasting is always allowed, but downcasting involves a type check and can throw a ClassCastException.
In your case, a cast from from Dog to an Animal is an upcast, because a Dog is-a Animal. In general, you can upcast whenever there is an is-a relationship between two classes.
Downcasting would be something like this:
Basically what you&#x27;re doing is telling the compiler that you know what the runtime type of the object really is. The compiler will allow the conversion, but will still insert a runtime sanity check to make sure that the conversion makes sense. In this case, the cast is possible because at runtime animal is actually a Dog even though the static type of animal is Animal.
However, if you were to do this:
You&#x27;d get a ClassCastException. The reason why is because animal&#x27;s runtime type is Animal, and so when you tell the runtime to perform the cast it sees that animal isn&#x27;t really a Dog and so throws a ClassCastException.
To call a superclass&#x27;s method you can do super.method() or by performing the upcast.
To call a subclass&#x27;s method you have to do a downcast. As shown above, you normally risk a ClassCastException by doing this; however, you can use the instanceof operator to check the runtime type of the object before performing the cast, which allows you to prevent ClassCastExceptions:

```java
Animal animal = new Dog();
Dog castedDog = (Dog) animal;
Animal animal = new Animal();
Dog notADog = (Dog) animal;
Animal animal = getAnimal(); // Maybe a Dog? Maybe a Cat? Maybe an Animal?
if (animal instanceof Dog) {
    // Guaranteed to succeed, barring classloader shenanigans
    Dog castedDog = (Dog) animal;
}
```

## Produced APIzation

[`APIzator23414798.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator23414798.java)

```java
package com.stackoverflow.api;

/**
 * What is the difference between up-casting and down-casting with respect to class variable
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/23414798">https://stackoverflow.com/a/23414798</a>
 */
public class APIzator23414798 {

  public static void be() throws RuntimeException {
    Animal animal = new Dog();
    Dog castedDog = (Dog) animal;
    Animal animal = new Animal();
    Dog notADog = (Dog) animal;
    // Maybe a Dog? Maybe a Cat? Maybe an Animal?
    Animal animal = getAnimal();
    if (animal instanceof Dog) {
      // Guaranteed to succeed, barring classloader shenanigans
      Dog castedDog = (Dog) animal;
    }
  }
}

```