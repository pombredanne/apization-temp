---
title: "[Q#3451670][A#3452620] Java AES and using my own Key"
question_title: "Java AES and using my own Key"
question_text: "I want to encrypt a string using AES with my own key. But I'm having trouble with the bit length of the key. Can you review my code and see what I need to fix/change. Right now I get an exception \"Invalid AES key length: 86 bytes\". Do I need to pad my key? How should I do it? Also do I need to set anything for ECB or CBC? Thanks"
answer_text: "You should use SHA-1 to generate a hash from your key and trim the result to 128 bit (16 bytes). Additionally don't generate byte arrays from Strings through getBytes() it uses the platform default Charset. So the password \"blaöä\" results in different byte array on different platforms. Edit: If you need 256 bit as key sizes you need to download the \"Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files\" Oracle download link, use SHA-256 as hash and remove the Arrays.copyOf line. \"ECB\" is the default Cipher Mode and \"PKCS5Padding\" the default padding. You could use different Cipher Modes and Padding Modes through the Cipher.getInstance string using following format: \"Cipher/Mode/Padding\" For AES using CTS and PKCS5Padding the string is: \"AES/CTS/PKCS5Padding\""
apization_code: "package com.stackoverflow.api;  import com.google.gwt.user.client.rpc.core.java.util.Arrays; import java.security.MessageDigest; import javax.crypto.spec.SecretKeySpec;  /**  * Java AES and using my own Key  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/3452620\">https://stackoverflow.com/a/3452620</a>  */ public class APIzator3452620 {    public static SecretKeySpec aes() throws RuntimeException {     byte[] key = (SALT2 + username + password).getBytes(\"UTF-8\");     MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");     key = sha.digest(key);     // use only first 128 bit     key = Arrays.copyOf(key, 16);     return new SecretKeySpec(key, \"AES\");   } }"
---

https://stackoverflow.com/q/3451670

I want to encrypt a string using AES with my own key. But I&#x27;m having trouble with the bit length of the key. Can you review my code and see what I need to fix/change.
Right now I get an exception &quot;Invalid AES key length: 86 bytes&quot;. Do I need to pad my key? How should I do it?
Also do I need to set anything for ECB or CBC?
Thanks


```java
public static void main(String[] args) throws Exception {
    String username = "bob@google.org";
    String password = "Password1";
    String secretID = "BlahBlahBlah";
    String SALT2 = "deliciously salty";

    // Get the Key
    byte[] key = (SALT2 + username + password).getBytes();
    System.out.println((SALT2 + username + password).getBytes().length);

    // Need to pad key for AES
    // TODO: Best way?

    // Generate the secret key specs.
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES");

    // Instantiate the cipher
    Cipher cipher = Cipher.getInstance("AES");
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);

    byte[] encrypted = cipher.doFinal((secrectID).getBytes());
    System.out.println("encrypted string: " + asHex(encrypted));

    cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
    byte[] original = cipher.doFinal(encrypted);
    String originalString = new String(original);
    System.out.println("Original string: " + originalString + "\nOriginal string (Hex): " + asHex(original));
}
```


## Original code snippet

https://stackoverflow.com/a/3452620

You should use SHA-1 to generate a hash from your key and trim the result to 128 bit (16 bytes).
Additionally don&#x27;t generate byte arrays from Strings through getBytes() it uses the platform default Charset. So the password &quot;blaöä&quot; results in different byte array on different platforms.
Edit:
If you need 256 bit as key sizes you need to download the &quot;Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files&quot; Oracle download link, use SHA-256 as hash and remove the Arrays.copyOf line.
&quot;ECB&quot; is the default Cipher Mode and &quot;PKCS5Padding&quot; the default padding.
You could use different Cipher Modes and Padding Modes through the Cipher.getInstance string using following format: &quot;Cipher/Mode/Padding&quot;
For AES using CTS and PKCS5Padding the string is: &quot;AES/CTS/PKCS5Padding&quot;

```java
byte[] key = (SALT2 + username + password).getBytes("UTF-8");
MessageDigest sha = MessageDigest.getInstance("SHA-1");
key = sha.digest(key);
key = Arrays.copyOf(key, 16); // use only first 128 bit

SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES");
```

## Produced APIzation

[`APIzator3452620.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator3452620.java)

```java
package com.stackoverflow.api;

import com.google.gwt.user.client.rpc.core.java.util.Arrays;
import java.security.MessageDigest;
import javax.crypto.spec.SecretKeySpec;

/**
 * Java AES and using my own Key
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/3452620">https://stackoverflow.com/a/3452620</a>
 */
public class APIzator3452620 {

  public static SecretKeySpec aes() throws RuntimeException {
    byte[] key = (SALT2 + username + password).getBytes("UTF-8");
    MessageDigest sha = MessageDigest.getInstance("SHA-1");
    key = sha.digest(key);
    // use only first 128 bit
    key = Arrays.copyOf(key, 16);
    return new SecretKeySpec(key, "AES");
  }
}

```