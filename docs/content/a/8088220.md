---
title: "[Q#8088179][A#8088220] Using Mockito with multiple calls to the same method with the same arguments"
question_title: "Using Mockito with multiple calls to the same method with the same arguments"
question_text: "Is there a way to have a stubbed method return different objects on subsequent invocations? I'd like to do this to test nondeterminate responses from an ExecutorCompletionService. i.e. to test that irrespective of the return order of the methods, the outcome remains constant. The code I'm looking to test looks something like this."
answer_text: "You can do that using the thenAnswer method (when chaining with when): Or using the equivalent, static doAnswer method:"
apization_code: "package com.stackoverflow.api;  import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer;  /**  * Using Mockito with multiple calls to the same method with the same arguments  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/8088220\">https://stackoverflow.com/a/8088220</a>  */ public class APIzator8088220 {    public static void useMockito() throws RuntimeException {     when(someMock.someMethod())       .thenAnswer(         new Answer() {           private int count = 0;            public Object answer(InvocationOnMock invocation) {             if (count++ == 1) return 1;             return 2;           }         }       );     doAnswer(       new Answer() {         private int count = 0;          public Object answer(InvocationOnMock invocation) {           if (count++ == 1) return 1;           return 2;         }       }     )       .when(someMock)       .someMethod();   } }"
---

https://stackoverflow.com/q/8088179

Is there a way to have a stubbed method return different objects on subsequent invocations? I&#x27;d like to do this to test nondeterminate responses from an ExecutorCompletionService. i.e. to test that irrespective of the return order of the methods, the outcome remains constant.
The code I&#x27;m looking to test looks something like this.


```java
// Create an completion service so we can group these tasks together
ExecutorCompletionService<T> completionService =
        new ExecutorCompletionService<T>(service);

// Add all these tasks to the completion service
for (Callable<T> t : ts)
    completionService.submit(request);

// As an when each call finished, add it to the response set.
for (int i = 0; i < calls.size(); i ++) {
    try {
        T t = completionService.take().get();
        // do some stuff that I want to test
    } catch (...) { }        
}
```


## Original code snippet

https://stackoverflow.com/a/8088220

You can do that using the thenAnswer method (when chaining with when):
Or using the equivalent, static doAnswer method:

```java
when(someMock.someMethod()).thenAnswer(new Answer() {
    private int count = 0;

    public Object answer(InvocationOnMock invocation) {
        if (count++ == 1)
            return 1;

        return 2;
    }
});
doAnswer(new Answer() {
    private int count = 0;

    public Object answer(InvocationOnMock invocation) {
        if (count++ == 1)
            return 1;

        return 2;
    }
}).when(someMock).someMethod();
```

## Produced APIzation

[`APIzator8088220.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator8088220.java)

```java
package com.stackoverflow.api;

import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

/**
 * Using Mockito with multiple calls to the same method with the same arguments
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/8088220">https://stackoverflow.com/a/8088220</a>
 */
public class APIzator8088220 {

  public static void useMockito() throws RuntimeException {
    when(someMock.someMethod())
      .thenAnswer(
        new Answer() {
          private int count = 0;

          public Object answer(InvocationOnMock invocation) {
            if (count++ == 1) return 1;
            return 2;
          }
        }
      );
    doAnswer(
      new Answer() {
        private int count = 0;

        public Object answer(InvocationOnMock invocation) {
          if (count++ == 1) return 1;
          return 2;
        }
      }
    )
      .when(someMock)
      .someMethod();
  }
}

```