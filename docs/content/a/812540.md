---
title: "[Q#812415][A#812540] Why is Spring's ApplicationContext.getBean considered bad?"
question_title: "Why is Spring's ApplicationContext.getBean considered bad?"
question_text: "I asked a general Spring question: Auto-cast Spring Beans and had multiple people respond that calling Spring's ApplicationContext.getBean() should be avoided as much as possible.  Why is that? How else should I gain access to the beans I configured Spring to create? I'm using Spring in a non-web application and had planned on accessing a shared ApplicationContext object as described by LiorH. Amendment I accept the answer below, but here's an alternate take by Martin Fowler who discusses the merits of Dependency Injection vs. using a Service Locator (which is essentially the same as calling a wrapped ApplicationContext.getBean()). In part, Fowler states, \"With service locator the application class asks for it [the service] explicitly by a message to the locator. With injection there is no explicit request, the service appears in the application class - hence the inversion of control. Inversion of control is a common feature of frameworks, but it's something that comes at a price. It tends to be hard to understand and leads to problems when you are trying to debug. So on the whole I prefer to avoid it [Inversion of Control] unless I need it. This isn't to say it's a bad thing, just that I think it needs to justify itself over the more straightforward alternative.\""
answer_text: "I mentioned this in a comment on the other question, but the whole idea of Inversion of Control is to have none of your classes know or care how they get the objects they depend on. This makes it easy to change what type of implementation of a given dependency you use at any time. It also makes the classes easy to test, as you can provide mock implementations of dependencies. Finally, it makes the classes simpler and more focused on their core responsibility. Calling ApplicationContext.getBean() is not Inversion of Control! While it's still easy to change what implemenation is configured for the given bean name, the class now relies directly on Spring to provide that dependency and can't get it any other way. You can't just make your own mock implementation in a test class and pass that to it yourself. This basically defeats Spring's purpose as a dependency injection container. Everywhere you want to say: you should instead, for example, declare a method: And then in your configuration: Spring will then automatically inject myClass into myOtherClass. Declare everything in this way, and at the root of it all have something like: MyApplication is the most central class, and depends at least indirectly on every other service in your program. When bootstrapping, in your main method, you can call applicationContext.getBean(\"myApplication\") but you should not need to call getBean() anywhere else!"
apization_code: "package com.stackoverflow.api;  /**  * Why is Spring's ApplicationContext.getBean considered bad?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/812540\">https://stackoverflow.com/a/812540</a>  */ public class APIzator812540 {   MyClass myClass = applicationContext.getBean(\"myClass\");    public static void setMyClass(MyClass myClass) {     this.myClass = myClass;   } }"
---

https://stackoverflow.com/q/812415

I asked a general Spring question: Auto-cast Spring Beans and had multiple people respond that calling Spring&#x27;s ApplicationContext.getBean() should be avoided as much as possible.  Why is that?
How else should I gain access to the beans I configured Spring to create?
I&#x27;m using Spring in a non-web application and had planned on accessing a shared ApplicationContext object as described by LiorH.
Amendment
I accept the answer below, but here&#x27;s an alternate take by Martin Fowler who discusses the merits of Dependency Injection vs. using a Service Locator (which is essentially the same as calling a wrapped ApplicationContext.getBean()).
In part, Fowler states, &quot;With service locator the application class asks for it [the service] explicitly by a message to the locator. With injection there is no explicit request, the service appears in the application class - hence the inversion of control.
Inversion of control is a common feature of frameworks, but it&#x27;s something that comes at a price. It tends to be hard to understand and leads to problems when you are trying to debug. So on the whole I prefer to avoid it [Inversion of Control] unless I need it. This isn&#x27;t to say it&#x27;s a bad thing, just that I think it needs to justify itself over the more straightforward alternative.&quot;



## Original code snippet

https://stackoverflow.com/a/812540

I mentioned this in a comment on the other question, but the whole idea of Inversion of Control is to have none of your classes know or care how they get the objects they depend on. This makes it easy to change what type of implementation of a given dependency you use at any time. It also makes the classes easy to test, as you can provide mock implementations of dependencies. Finally, it makes the classes simpler and more focused on their core responsibility.
Calling ApplicationContext.getBean() is not Inversion of Control! While it&#x27;s still easy to change what implemenation is configured for the given bean name, the class now relies directly on Spring to provide that dependency and can&#x27;t get it any other way. You can&#x27;t just make your own mock implementation in a test class and pass that to it yourself. This basically defeats Spring&#x27;s purpose as a dependency injection container.
Everywhere you want to say:
you should instead, for example, declare a method:
And then in your configuration:
Spring will then automatically inject myClass into myOtherClass.
Declare everything in this way, and at the root of it all have something like:
MyApplication is the most central class, and depends at least indirectly on every other service in your program. When bootstrapping, in your main method, you can call applicationContext.getBean(&quot;myApplication&quot;) but you should not need to call getBean() anywhere else!

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
MyClass myClass = applicationContext.getBean("myClass");
public void setMyClass(MyClass myClass) {
   this.myClass = myClass;
}
<bean id="myClass" class="MyClass">...</bean>

<bean id="myOtherClass" class="MyOtherClass">
   <property name="myClass" ref="myClass"/>
</bean>
<bean id="myApplication" class="MyApplication">
   <property name="myCentralClass" ref="myCentralClass"/>
   <property name="myOtherCentralClass" ref="myOtherCentralClass"/>
</bean>
```

## Produced APIzation

[`APIzator812540.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator812540.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

/**
 * Why is Spring's ApplicationContext.getBean considered bad?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/812540">https://stackoverflow.com/a/812540</a>
 */
public class APIzator812540 {
  MyClass myClass = applicationContext.getBean("myClass");

  public static void setMyClass(MyClass myClass) {
    this.myClass = myClass;
  }
}

```