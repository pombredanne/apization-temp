---
title: "[Q#3802370][A#3802420] Java time-based map/cache with expiring keys"
question_title: "Java time-based map/cache with expiring keys"
question_text: "Do any of you know of a Java Map or similar standard data store that automatically purges entries after a given timeout? This means aging, where the old expired entries “age-out” automatically. Preferably in an open source library that is accessible via Maven? I know of ways to implement the functionality myself and have done it several times in the past, so I'm not asking for advice in that respect, but for pointers to a good reference implementation. WeakReference based solutions like WeakHashMap are not an option, because my keys are likely to be non-interned strings and I want a configurable timeout that's not dependent on the garbage collector. Ehcache is also an option I wouldn't like to rely on because it needs external configuration files. I am looking for a code-only solution."
answer_text: "Yes. Google Collections, or Guava as it is named now has something called MapMaker which can do exactly that. Update: As of guava 10.0 (released September 28, 2011) many of these MapMaker methods have been deprecated in favour of the new CacheBuilder:"
apization_code: "package com.stackoverflow.api;  import avro.shaded.com.google.common.cache.CacheBuilder; import avro.shaded.com.google.common.cache.CacheLoader; import avro.shaded.com.google.common.cache.LoadingCache; import avro.shaded.com.google.common.collect.MapMaker; import com.google.appengine.api.datastore.Key; import com.google.appengine.repackaged.com.google.common.graph.Graph; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.TimeUnit; import net.sf.cglib.core.internal.Function;  /**  * Java time-based map/cache with expiring keys  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/3802420\">https://stackoverflow.com/a/3802420</a>  */ public class APIzator3802420 {    public static LoadingCache<Key, Graph> cache() throws RuntimeException {     ConcurrentMap<Key, Graph> graphs = new MapMaker()       .concurrencyLevel(4)       .softKeys()       .weakValues()       .maximumSize(10000)       .expiration(10, TimeUnit.MINUTES)       .makeComputingMap(         new Function<Key, Graph>() {            public Graph apply(Key key) {             return createExpensiveGraph(key);           }         }       );     return CacheBuilder       .newBuilder()       .maximumSize(10000)       .expireAfterWrite(10, TimeUnit.MINUTES)       .build(         new CacheLoader<Key, Graph>() {            public Graph load(Key key) throws AnyException {             return createExpensiveGraph(key);           }         }       );   } }"
---

https://stackoverflow.com/q/3802370

Do any of you know of a Java Map or similar standard data store that automatically purges entries after a given timeout? This means aging, where the old expired entries “age-out” automatically.
Preferably in an open source library that is accessible via Maven?
I know of ways to implement the functionality myself and have done it several times in the past, so I&#x27;m not asking for advice in that respect, but for pointers to a good reference implementation.
WeakReference based solutions like WeakHashMap are not an option, because my keys are likely to be non-interned strings and I want a configurable timeout that&#x27;s not dependent on the garbage collector.
Ehcache is also an option I wouldn&#x27;t like to rely on because it needs external configuration files. I am looking for a code-only solution.



## Original code snippet

https://stackoverflow.com/a/3802420

Yes. Google Collections, or Guava as it is named now has something called MapMaker which can do exactly that.
Update:
As of guava 10.0 (released September 28, 2011) many of these MapMaker methods have been deprecated in favour of the new CacheBuilder:

```java
ConcurrentMap<Key, Graph> graphs = new MapMaker()
   .concurrencyLevel(4)
   .softKeys()
   .weakValues()
   .maximumSize(10000)
   .expiration(10, TimeUnit.MINUTES)
   .makeComputingMap(
       new Function<Key, Graph>() {
         public Graph apply(Key key) {
           return createExpensiveGraph(key);
         }
       });
LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()
    .maximumSize(10000)
    .expireAfterWrite(10, TimeUnit.MINUTES)
    .build(
        new CacheLoader<Key, Graph>() {
          public Graph load(Key key) throws AnyException {
            return createExpensiveGraph(key);
          }
        });
```

## Produced APIzation

[`APIzator3802420.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator3802420.java)

```java
package com.stackoverflow.api;

import avro.shaded.com.google.common.cache.CacheBuilder;
import avro.shaded.com.google.common.cache.CacheLoader;
import avro.shaded.com.google.common.cache.LoadingCache;
import avro.shaded.com.google.common.collect.MapMaker;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.repackaged.com.google.common.graph.Graph;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import net.sf.cglib.core.internal.Function;

/**
 * Java time-based map/cache with expiring keys
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/3802420">https://stackoverflow.com/a/3802420</a>
 */
public class APIzator3802420 {

  public static LoadingCache<Key, Graph> cache() throws RuntimeException {
    ConcurrentMap<Key, Graph> graphs = new MapMaker()
      .concurrencyLevel(4)
      .softKeys()
      .weakValues()
      .maximumSize(10000)
      .expiration(10, TimeUnit.MINUTES)
      .makeComputingMap(
        new Function<Key, Graph>() {

          public Graph apply(Key key) {
            return createExpensiveGraph(key);
          }
        }
      );
    return CacheBuilder
      .newBuilder()
      .maximumSize(10000)
      .expireAfterWrite(10, TimeUnit.MINUTES)
      .build(
        new CacheLoader<Key, Graph>() {

          public Graph load(Key key) throws AnyException {
            return createExpensiveGraph(key);
          }
        }
      );
  }
}

```