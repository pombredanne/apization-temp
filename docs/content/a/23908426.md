---
title: "[Q#481813][A#23908426] How to simplify a null-safe compareTo() implementation?"
question_title: "How to simplify a null-safe compareTo() implementation?"
question_text: "I'm implementing compareTo() method for a simple class such as this (to be able to use Collections.sort() and other goodies offered by the Java platform): I want the natural ordering for these objects to be: 1) sorted by name and 2) sorted by value if name is the same; both comparisons should be case-insensitive. For both fields null values are perfectly acceptable, so compareTo must not break in these cases. The solution that springs to mind is along the lines of the following (I'm using \"guard clauses\" here while others might prefer a single return point, but that's beside the point): This does the job, but I'm not perfectly happy with this code. Admittedly it isn't very complex, but is quite verbose and tedious. The question is, how would you make this less verbose (while retaining the functionality)? Feel free to refer to Java standard libraries or Apache Commons if they help. Would the only option to make this (a little) simpler be to implement my own \"NullSafeStringComparator\", and apply it for comparing both fields? Edits 1-3: Eddie's right; fixed the \"both names are null\" case above I asked this question back in 2009, on Java 1.6 of course, and at the time the pure JDK solution by Eddie was my preferred accepted answer. I never got round to changing that until now (2017). There are also 3rd party library solutions—a 2009 Apache Commons Collections one and a 2013 Guava one, both posted by me—that I did prefer at some point in time. I now made the clean Java 8 solution by Lukasz Wiktor the accepted answer. That should definitely be preferred if on Java 8, and these days Java 8 should be available to nearly all projects."
answer_text: "Using Java 8:"
apization_code: "package com.stackoverflow.api;  import com.google.appengine.repackaged.com.google.common.flogger.backend.Metadata; import com.sun.org.apache.xpath.internal.objects.Comparator;  /**  * How to simplify a null-safe compareTo() implementation?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/23908426\">https://stackoverflow.com/a/23908426</a>  */ public class APIzator23908426 {   private static Comparator<String> nullSafeStringComparator = Comparator.nullsFirst(     String::compareToIgnoreCase   );    private static Comparator<Metadata> metadataComparator = Comparator     .comparing(Metadata::getName, nullSafeStringComparator)     .thenComparing(Metadata::getValue, nullSafeStringComparator);    public static int compareTo(Metadata that) {     return metadataComparator.compare(this, that);   } }"
---

https://stackoverflow.com/q/481813

I&#x27;m implementing compareTo() method for a simple class such as this (to be able to use Collections.sort() and other goodies offered by the Java platform):
I want the natural ordering for these objects to be: 1) sorted by name and 2) sorted by value if name is the same; both comparisons should be case-insensitive. For both fields null values are perfectly acceptable, so compareTo must not break in these cases.
The solution that springs to mind is along the lines of the following (I&#x27;m using &quot;guard clauses&quot; here while others might prefer a single return point, but that&#x27;s beside the point):
This does the job, but I&#x27;m not perfectly happy with this code. Admittedly it isn&#x27;t very complex, but is quite verbose and tedious.
The question is, how would you make this less verbose (while retaining the functionality)? Feel free to refer to Java standard libraries or Apache Commons if they help. Would the only option to make this (a little) simpler be to implement my own &quot;NullSafeStringComparator&quot;, and apply it for comparing both fields?
Edits 1-3: Eddie&#x27;s right; fixed the &quot;both names are null&quot; case above
I asked this question back in 2009, on Java 1.6 of course, and at the time the pure JDK solution by Eddie was my preferred accepted answer. I never got round to changing that until now (2017).
There are also 3rd party library solutions—a 2009 Apache Commons Collections one and a 2013 Guava one, both posted by me—that I did prefer at some point in time.
I now made the clean Java 8 solution by Lukasz Wiktor the accepted answer. That should definitely be preferred if on Java 8, and these days Java 8 should be available to nearly all projects.


```java
public class Metadata implements Comparable<Metadata> {
    private String name;
    private String value;

// Imagine basic constructor and accessors here
// Irrelevant parts omitted
}
// primarily by name, secondarily by value; null-safe; case-insensitive
public int compareTo(Metadata other) {
    if (this.name == null && other.name != null){
        return -1;
    }
    else if (this.name != null && other.name == null){
        return 1;
    }
    else if (this.name != null && other.name != null) {
        int result = this.name.compareToIgnoreCase(other.name);
        if (result != 0){
            return result;
        }
    }

    if (this.value == null) {
        return other.value == null ? 0 : -1;
    }
    if (other.value == null){
        return 1;
    }

    return this.value.compareToIgnoreCase(other.value);
}
```


## Original code snippet

https://stackoverflow.com/a/23908426

Using Java 8:

```java
private static Comparator<String> nullSafeStringComparator = Comparator
        .nullsFirst(String::compareToIgnoreCase); 

private static Comparator<Metadata> metadataComparator = Comparator
        .comparing(Metadata::getName, nullSafeStringComparator)
        .thenComparing(Metadata::getValue, nullSafeStringComparator);

public int compareTo(Metadata that) {
    return metadataComparator.compare(this, that);
}
```

## Produced APIzation

[`APIzator23908426.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator23908426.java)

```java
package com.stackoverflow.api;

import com.google.appengine.repackaged.com.google.common.flogger.backend.Metadata;
import com.sun.org.apache.xpath.internal.objects.Comparator;

/**
 * How to simplify a null-safe compareTo() implementation?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/23908426">https://stackoverflow.com/a/23908426</a>
 */
public class APIzator23908426 {
  private static Comparator<String> nullSafeStringComparator = Comparator.nullsFirst(
    String::compareToIgnoreCase
  );

  private static Comparator<Metadata> metadataComparator = Comparator
    .comparing(Metadata::getName, nullSafeStringComparator)
    .thenComparing(Metadata::getValue, nullSafeStringComparator);

  public static int compareTo(Metadata that) {
    return metadataComparator.compare(this, that);
  }
}

```