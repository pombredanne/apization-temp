---
title: "[Q#137212][A#137288] How to solve slow Java `SecureRandom`?"
question_title: "How to solve slow Java `SecureRandom`?"
question_text: "If you want a cryptographically strong random number in Java, you use SecureRandom. Unfortunately, SecureRandom can be very slow. If it uses /dev/random on Linux, it can block waiting for sufficient entropy to build up. How do you avoid the performance penalty? Has anyone used Uncommon Maths as a solution to this problem? Can anybody confirm that this performance problem has been solved in JDK 6?"
answer_text: "If you want true random data, then unfortunately you have to wait for it. This includes the seed for a SecureRandom PRNG. Uncommon Maths can't gather true random data any faster than SecureRandom, although it can connect to the internet to download seed data from a particular website. My guess is that this is unlikely to be faster than /dev/random where that's available. If you want a PRNG, do something like this: What strings are supported depends on the SecureRandom SPI provider, but you can enumerate them using Security.getProviders() and Provider.getService(). Sun is fond of SHA1PRNG, so it's widely available. It isn't especially fast as PRNGs go, but PRNGs will just be crunching numbers, not blocking for physical measurement of entropy. The exception is that if you don't call setSeed() before getting data, then the PRNG will seed itself once the first time you call next() or nextBytes(). It will usually do this using a fairly small amount of true random data from the system. This call may block, but will make your source of random numbers far more secure than any variant of \"hash the current time together with the PID, add 27, and hope for the best\". If all you need is random numbers for a game, though, or if you want the stream to be repeatable in future using the same seed for testing purposes, an insecure seed is still useful."
apization_code: "package com.stackoverflow.api;  import java.security.SecureRandom;  /**  * How to solve slow Java `SecureRandom`?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/137288\">https://stackoverflow.com/a/137288</a>  */ public class APIzator137288 {    public static void solveJava() throws RuntimeException {     SecureRandom.getInstance(\"SHA1PRNG\");   } }"
---

https://stackoverflow.com/q/137212

If you want a cryptographically strong random number in Java, you use SecureRandom. Unfortunately, SecureRandom can be very slow. If it uses /dev/random on Linux, it can block waiting for sufficient entropy to build up. How do you avoid the performance penalty?
Has anyone used Uncommon Maths as a solution to this problem?
Can anybody confirm that this performance problem has been solved in JDK 6?



## Original code snippet

https://stackoverflow.com/a/137288

If you want true random data, then unfortunately you have to wait for it. This includes the seed for a SecureRandom PRNG. Uncommon Maths can&#x27;t gather true random data any faster than SecureRandom, although it can connect to the internet to download seed data from a particular website. My guess is that this is unlikely to be faster than /dev/random where that&#x27;s available.
If you want a PRNG, do something like this:
What strings are supported depends on the SecureRandom SPI provider, but you can enumerate them using Security.getProviders() and Provider.getService().
Sun is fond of SHA1PRNG, so it&#x27;s widely available. It isn&#x27;t especially fast as PRNGs go, but PRNGs will just be crunching numbers, not blocking for physical measurement of entropy.
The exception is that if you don&#x27;t call setSeed() before getting data, then the PRNG will seed itself once the first time you call next() or nextBytes(). It will usually do this using a fairly small amount of true random data from the system. This call may block, but will make your source of random numbers far more secure than any variant of &quot;hash the current time together with the PID, add 27, and hope for the best&quot;. If all you need is random numbers for a game, though, or if you want the stream to be repeatable in future using the same seed for testing purposes, an insecure seed is still useful.

```java
SecureRandom.getInstance("SHA1PRNG");
```

## Produced APIzation

[`APIzator137288.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator137288.java)

```java
package com.stackoverflow.api;

import java.security.SecureRandom;

/**
 * How to solve slow Java `SecureRandom`?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/137288">https://stackoverflow.com/a/137288</a>
 */
public class APIzator137288 {

  public static void solveJava() throws RuntimeException {
    SecureRandom.getInstance("SHA1PRNG");
  }
}

```