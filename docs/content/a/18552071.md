---
title: "[Q#18552005][A#18552071] Is there a concise way to iterate over a stream with indices in Java 8?"
question_title: "Is there a concise way to iterate over a stream with indices in Java 8?"
question_text: "Is there a concise way to iterate over a stream whilst having access to the index in the stream? which seems rather disappointing compared to the LINQ example given there Is there a more concise way? Further it seems the zip has either moved or been removed..."
answer_text: "The cleanest way is to start from a stream of indices: The resulting list contains \"Erik\" only. One alternative which looks more familiar when you are used to for loops would be to maintain an ad hoc counter using a mutable object, for example an AtomicInteger: Note that using the latter method on a parallel stream could break as the items would not necesarily be processed \"in order\"."
apization_code: "package com.stackoverflow.api;  import java.util.Arrays; import java.util.List; import java.util.concurrent.atomic.AtomicInteger; import java.util.stream.Collectors; import java.util.stream.IntStream;  /**  * Is there a concise way to iterate over a stream with indices in Java 8?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/18552071\">https://stackoverflow.com/a/18552071</a>  */ public class APIzator18552071 {    public static List<String> be(String[] names, String[] names)     throws RuntimeException {     IntStream       .range(0, names.length)       .filter(i -> names[i].length() <= i)       .mapToObj(i -> names[i])       .collect(Collectors.toList());     AtomicInteger index = new AtomicInteger();     return Arrays       .stream(names)       .filter(n -> n.length() <= index.incrementAndGet())       .collect(Collectors.toList());   } }"
---

https://stackoverflow.com/q/18552005

Is there a concise way to iterate over a stream whilst having access to the index in the stream?
which seems rather disappointing compared to the LINQ example given there
Is there a more concise way?
Further it seems the zip has either moved or been removed...


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
String[] names = {"Sam","Pamela", "Dave", "Pascal", "Erik"};

List<String> nameList;
Stream<Integer> indices = intRange(1, names.length).boxed();
nameList = zip(indices, stream(names), SimpleEntry::new)
        .filter(e -> e.getValue().length() <= e.getKey())
        .map(Entry::getValue)
        .collect(toList());
string[] names = { "Sam", "Pamela", "Dave", "Pascal", "Erik" };
var nameList = names.Where((c, index) => c.Length <= index + 1).ToList();
```


## Original code snippet

https://stackoverflow.com/a/18552071

The cleanest way is to start from a stream of indices:
The resulting list contains &quot;Erik&quot; only.
One alternative which looks more familiar when you are used to for loops would be to maintain an ad hoc counter using a mutable object, for example an AtomicInteger:
Note that using the latter method on a parallel stream could break as the items would not necesarily be processed &quot;in order&quot;.

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"};
IntStream.range(0, names.length)
         .filter(i -> names[i].length() <= i)
         .mapToObj(i -> names[i])
         .collect(Collectors.toList());
String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"};
AtomicInteger index = new AtomicInteger();
List<String> list = Arrays.stream(names)
                          .filter(n -> n.length() <= index.incrementAndGet())
                          .collect(Collectors.toList());
```

## Produced APIzation

[`APIzator18552071.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator18552071.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Is there a concise way to iterate over a stream with indices in Java 8?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/18552071">https://stackoverflow.com/a/18552071</a>
 */
public class APIzator18552071 {

  public static List<String> be(String[] names, String[] names)
    throws RuntimeException {
    IntStream
      .range(0, names.length)
      .filter(i -> names[i].length() <= i)
      .mapToObj(i -> names[i])
      .collect(Collectors.toList());
    AtomicInteger index = new AtomicInteger();
    return Arrays
      .stream(names)
      .filter(n -> n.length() <= index.incrementAndGet())
      .collect(Collectors.toList());
  }
}

```