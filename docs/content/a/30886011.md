---
title: "[Q#1778744][A#30886011] Using Mockito's generic \"any()\" method"
question_title: "Using Mockito's generic \"any()\" method"
question_text: "I have an interface with a method that expects an array of Foo: I am mocking this interface using Mockito, and I'd like to assert that doStuff() is called, but I don't want to validate what argument are passed - \"don't care\". How do I write the following code using any(), the generic method, instead of anyObject()?"
answer_text: "Since Java 8 you can use the argument-less any method and the type argument will get inferred by the compiler: The new thing in Java 8 is that the target type of an expression will be used to infer type parameters of its sub-expressions. Before Java 8 only arguments to methods where used for type parameter inference (most of the time). In this case the parameter type of doStuff will be the target type for any(), and the return value type of any() will get chosen to match that argument type. This doesn't work with primitive types, unfortunately: The problem is that the compiler will infer Integer as the return value of any(). Mockito will not be aware of this (due to type erasure) and return the default value for reference types, which is null. The runtime will try to unbox the return value by calling the intValue method on it before passing it to doStuff, and the exception will get thrown."
apization_code: "package com.stackoverflow.api;  /**  * Using Mockito's generic \"any()\" method  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/30886011\">https://stackoverflow.com/a/30886011</a>  */ public class APIzator30886011 {    public static void useMockito() throws RuntimeException {     verify(bar).doStuff(any());   } }"
---

https://stackoverflow.com/q/1778744

I have an interface with a method that expects an array of Foo:
I am mocking this interface using Mockito, and I&#x27;d like to assert that doStuff() is called, but I don&#x27;t want to validate what argument are passed - &quot;don&#x27;t care&quot;.
How do I write the following code using any(), the generic method, instead of anyObject()?


```java
public interface IBar {
  void doStuff(Foo[] arr);
}
IBar bar = mock(IBar.class);
...
verify(bar).doStuff((Foo[]) anyObject());
```


## Original code snippet

https://stackoverflow.com/a/30886011

Since Java 8 you can use the argument-less any method and the type argument will get inferred by the compiler:
The new thing in Java 8 is that the target type of an expression will be used to infer type parameters of its sub-expressions. Before Java 8 only arguments to methods where used for type parameter inference (most of the time).
In this case the parameter type of doStuff will be the target type for any(), and the return value type of any() will get chosen to match that argument type.
This doesn&#x27;t work with primitive types, unfortunately:
The problem is that the compiler will infer Integer as the return value of any(). Mockito will not be aware of this (due to type erasure) and return the default value for reference types, which is null. The runtime will try to unbox the return value by calling the intValue method on it before passing it to doStuff, and the exception will get thrown.

```java
verify(bar).doStuff(any());
public interface IBar {
    void doPrimitiveStuff(int i);
}

verify(bar).doPrimitiveStuff(any()); // Compiles but throws NullPointerException
verify(bar).doPrimitiveStuff(anyInt()); // This is what you have to do instead
```

## Produced APIzation

[`APIzator30886011.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator30886011.java)

```java
package com.stackoverflow.api;

/**
 * Using Mockito's generic "any()" method
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/30886011">https://stackoverflow.com/a/30886011</a>
 */
public class APIzator30886011 {

  public static void useMockito() throws RuntimeException {
    verify(bar).doStuff(any());
  }
}

```