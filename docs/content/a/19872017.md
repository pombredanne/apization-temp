---
title: "[Q#19871955][A#19872017] java.io.FileNotFoundException: the system cannot find the file specified"
question_title: "java.io.FileNotFoundException: the system cannot find the file specified"
question_text: "So I have been stuck on this for a while. Basically, I have a file created called \"word.txt\" and whenever I run the program it gives me this error: Here's my code: Ironically, I created the file \"word.txt\" in the same directory as my java file and yet, it's still giving me that error."
answer_text: "Put the word.txt directly as a child of the project root folder and a peer of src Disclaimer: I'd like to explain why this works for this particular case and why it may not work for others. Why it works: When you use File or any of the other FileXxx variants, you are looking for a file on the file system relative to the \"working directory\". The working directory, can be described as this: When you run from the command line C:\\EclipseWorkspace\\ProjectRoot\\bin > java com.mypackage.Hangman1 the working directory is C:\\EclipseWorkspace\\ProjectRoot\\bin. With your IDE (at least all the ones I've worked with), the working directory is the ProjectRoot. So when the file is in the ProjectRoot, then using just the file name as the relative path is valid, because it is at the root of the working directory. Similarly, if this was your project structure ProjectRoot\\src\\word.txt, then the path \"src/word.txt\" would be valid. Why it May not Work For one, the working directory could always change. For instance, running the code from the command line like in the example above, the working directory is the bin. So in this case it will fail, as there is not bin\\word.txt Secondly, if you were to export this project into a jar, and the file was configured to be included in the jar, it would also fail, as the path will no longer be valid either. That being said, you need to determine if the file is to be an embedded-resource (or just \"resource\" - terms which sometimes I'll use interchangeably). If so, then you will want to build the file into the classpath, and access it via an URL. First thing you would need to do (in this particular) case is make sure that the file get built into the classpath. With the file in the project root, you must configure the build to include the file. But if you put the file in the src or in some directory below, then the default build should put it into the class path. You can access classpath resource in a number of ways. You can make use of the Class class, which has getResourceXxx method, from which you use to obtain classpath resources. For example, if you changed your project structure to ProjectRoot\\src\\resources\\word.txt, you could use this: getResourceAsStream returns an InputStream, but obtains an URL under the hood. Alternatively, you could get an URL if that's what you need. getResource() will return an URL For Maven users, where the directory structure is like src/main/resources, the contents of the resources folder is put at the root of the classpath. So if you have a file in there, then you would only use getResourceAsStream(\"/thefile.txt\")"
apization_code: "package com.stackoverflow.api;  import org.omg.CORBA.portable.InputStream;  /**  * java.io.FileNotFoundException: the system cannot find the file specified  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/19872017\">https://stackoverflow.com/a/19872017</a>  */ public class APIzator19872017 {    public static BufferedReader javaio(String str1) throws RuntimeException {     InputStream is = Hangman1.class.getResourceAsStream(str1);     return new BufferedReader(new InputStreamReader(is));   } }"
---

https://stackoverflow.com/q/19871955

So I have been stuck on this for a while. Basically, I have a file created called &quot;word.txt&quot; and whenever I run the program it gives me this error:
Here&#x27;s my code:
Ironically, I created the file &quot;word.txt&quot; in the same directory as my java file and yet, it&#x27;s still giving me that error.


```java
Exception in thread "main" java.io.FileNotFoundException: word.txt (The system cannot find the file specified)
    at java.io.FileInputStream.open(Native Method)
    at java.io.FileInputStream.<init>(Unknown Source)
    at java.util.Scanner.<init>(Unknown Source)
    at Hangman1.main(Hangman1.java:6)
import java.io.File;
import java.util.*;

public class Hangman1 {
    public static void main(String[] args) throws Exception {
        Scanner input = new Scanner(new File("word.txt"));          
        String in = "";         
        in = input.nextLine();          
    }
}
```


## Original code snippet

https://stackoverflow.com/a/19872017

Put the word.txt directly as a child of the project root folder and a peer of src
Disclaimer: I&#x27;d like to explain why this works for this particular case and why it may not work for others.
Why it works:
When you use File or any of the other FileXxx variants, you are looking for a file on the file system relative to the &quot;working directory&quot;. The working directory, can be described as this:
When you run from the command line
C:\EclipseWorkspace\ProjectRoot\bin &gt; java com.mypackage.Hangman1
the working directory is C:\EclipseWorkspace\ProjectRoot\bin. With your IDE (at least all the ones I&#x27;ve worked with), the working directory is the ProjectRoot. So when the file is in the ProjectRoot, then using just the file name as the relative path is valid, because it is at the root of the working directory.
Similarly, if this was your project structure ProjectRoot\src\word.txt, then the path &quot;src/word.txt&quot; would be valid.
Why it May not Work
For one, the working directory could always change. For instance, running the code from the command line like in the example above, the working directory is the bin. So in this case it will fail, as there is not bin\word.txt
Secondly, if you were to export this project into a jar, and the file was configured to be included in the jar, it would also fail, as the path will no longer be valid either.
That being said, you need to determine if the file is to be an embedded-resource (or just &quot;resource&quot; - terms which sometimes I&#x27;ll use interchangeably). If so, then you will want to build the file into the classpath, and access it via an URL. First thing you would need to do (in this particular) case is make sure that the file get built into the classpath. With the file in the project root, you must configure the build to include the file. But if you put the file in the src or in some directory below, then the default build should put it into the class path.
You can access classpath resource in a number of ways. You can make use of the Class class, which has getResourceXxx method, from which you use to obtain classpath resources.
For example, if you changed your project structure to ProjectRoot\src\resources\word.txt, you could use this:
getResourceAsStream returns an InputStream, but obtains an URL under the hood. Alternatively, you could get an URL if that&#x27;s what you need. getResource() will return an URL
For Maven users, where the directory structure is like src/main/resources, the contents of the resources folder is put at the root of the classpath. So if you have a file in there, then you would only use getResourceAsStream(&quot;/thefile.txt&quot;)

```java
Project_Root
    src
    word.txt
InputStream is = Hangman1.class.getResourceAsStream("/resources/word.txt");
BufferedReader reader = new BufferedReader(new InputStreamReader(is));
```

## Produced APIzation

[`APIzator19872017.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator19872017.java)

```java
package com.stackoverflow.api;

import org.omg.CORBA.portable.InputStream;

/**
 * java.io.FileNotFoundException: the system cannot find the file specified
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/19872017">https://stackoverflow.com/a/19872017</a>
 */
public class APIzator19872017 {

  public static BufferedReader javaio(String str1) throws RuntimeException {
    InputStream is = Hangman1.class.getResourceAsStream(str1);
    return new BufferedReader(new InputStreamReader(is));
  }
}

```