---
title: "[Q#2707322][A#2707333] What is null in Java?"
question_title: "What is null in Java?"
question_text: "What is null? Is null an instance of anything? What set does null belong to? How is it represented in the memory?"
answer_text: "Is null an instance of anything? No, there is no type which null is an instanceof. At run time, the result of the instanceof operator is true if the value of the RelationalExpression is not null and the reference could be cast to the ReferenceType without raising a ClassCastException. Otherwise the result is false. This means that for any type E and R, for any E o, where o == null, o instanceof R is always false. What set does 'null' belong to? There is also a special null type, the type of the expression null, which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be cast to any reference type. In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type. What is null? As the JLS quote above says, in practice you can simply pretend that it's \"merely a special literal that can be of any reference type\". In Java, null == null (this isn't always the case in other languages). Note also that by contract, it also has this special property (from java.lang.Object): public boolean equals(Object obj) For any non-null reference value x, x.equals(null) should return false. It is also the default value (for variables that have them) for all reference types: How this is used varies. You can use it to enable what is called lazy initialization of fields, where a field would have its initial value of null until it's actually used, where it's replaced by the \"real\" value (which may be expensive to compute). There are also other uses. Let's take a real example from java.lang.System: public static Console console() Returns: The system console, if any, otherwise null. This is a very common use pattern: null is used to denote non-existence of an object. Here's another usage example, this time from java.io.BufferedReader: public String readLine() throws IOException Returns: A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached. So here, readLine() would return instanceof String for each line, until it finally returns a null to signify the end. This allows you to process each line as follows: One can design the API so that the termination condition doesn't depend on readLine() returning null, but one can see that this design has the benefit of making things concise. Note that there is no problem with empty lines, because an empty line \"\" != null. Let's take another example, this time from java.util.Map<K,V>: V get(Object key) Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases. Here we start to see how using null can complicate things. The first statement says that if the key isn't mapped, null is returned. The second statement says that even if the key is mapped, null can also be returned. In contrast, java.util.Hashtable keeps things simpler by not permitting null keys and values; its V get(Object key), if returns null, unambiguously means that the key isn't mapped. You can read through the rest of the APIs and find where and how null is used. Do keep in mind that they aren't always the best practice examples. Generally speaking, null are used as a special value to signify: How is it represented in the memory? In Java? None of your concern. And it's best kept that way. This is now borderline subjective. Some people say that null causes many programmer errors that could've been avoided. Some say that in a language that catches NullPointerException like Java, it's good to use it because you will fail-fast on programmer errors. Some people avoid null by using Null object pattern, etc. This is a huge topic on its own, so it's best discussed as answer to another question. I will end this with a quote from the inventor of null himself, C.A.R Hoare (of quicksort fame): I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. The video of this presentation goes deeper; it's a recommended watch."
apization_code: "package com.stackoverflow.api;  /**  * What is null in Java?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/2707333\">https://stackoverflow.com/a/2707333</a>  */ public class APIzator2707333 {    public static void be() throws RuntimeException {     String line;     while ((line = reader.readLine()) != null) {       process(line);     }   } }"
---

https://stackoverflow.com/q/2707322

What is null?
Is null an instance of anything?
What set does null belong to?
How is it represented in the memory?



## Original code snippet

https://stackoverflow.com/a/2707333

Is null an instance of anything?
No, there is no type which null is an instanceof.
At run time, the result of the instanceof operator is true if the value of the RelationalExpression is not null and the reference could be cast to the ReferenceType without raising a ClassCastException. Otherwise the result is false.
This means that for any type E and R, for any E o, where o == null, o instanceof R is always false.
What set does &#x27;null&#x27; belong to?
There is also a special null type, the type of the expression null, which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be cast to any reference type. In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.
What is null?
As the JLS quote above says, in practice you can simply pretend that it&#x27;s &quot;merely a special literal that can be of any reference type&quot;.
In Java, null == null (this isn&#x27;t always the case in other languages). Note also that by contract, it also has this special property (from java.lang.Object):
public boolean equals(Object obj)
For any non-null reference value x, x.equals(null) should return false.
It is also the default value (for variables that have them) for all reference types:
How this is used varies. You can use it to enable what is called lazy initialization of fields, where a field would have its initial value of null until it&#x27;s actually used, where it&#x27;s replaced by the &quot;real&quot; value (which may be expensive to compute).
There are also other uses. Let&#x27;s take a real example from java.lang.System:
public static Console console()
Returns: The system console, if any, otherwise null.
This is a very common use pattern: null is used to denote non-existence of an object.
Here&#x27;s another usage example, this time from java.io.BufferedReader:
public String readLine() throws IOException
Returns: A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached.
So here, readLine() would return instanceof String for each line, until it finally returns a null to signify the end. This allows you to process each line as follows:
One can design the API so that the termination condition doesn&#x27;t depend on readLine() returning null, but one can see that this design has the benefit of making things concise. Note that there is no problem with empty lines, because an empty line &quot;&quot; != null.
Let&#x27;s take another example, this time from java.util.Map&lt;K,V&gt;:
V get(Object key)
Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it&#x27;s also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
Here we start to see how using null can complicate things. The first statement says that if the key isn&#x27;t mapped, null is returned. The second statement says that even if the key is mapped, null can also be returned.
In contrast, java.util.Hashtable keeps things simpler by not permitting null keys and values; its V get(Object key), if returns null, unambiguously means that the key isn&#x27;t mapped.
You can read through the rest of the APIs and find where and how null is used. Do keep in mind that they aren&#x27;t always the best practice examples.
Generally speaking, null are used as a special value to signify:
How is it represented in the memory?
In Java? None of your concern. And it&#x27;s best kept that way.
This is now borderline subjective. Some people say that null causes many programmer errors that could&#x27;ve been avoided. Some say that in a language that catches NullPointerException like Java, it&#x27;s good to use it because you will fail-fast on programmer errors. Some people avoid null by using Null object pattern, etc.
This is a huge topic on its own, so it&#x27;s best discussed as answer to another question.
I will end this with a quote from the inventor of null himself, C.A.R Hoare (of quicksort fame):
I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&#x27;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.
The video of this presentation goes deeper; it&#x27;s a recommended watch.

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
RelationalExpression:
    RelationalExpression instanceof ReferenceType
String line;
while ((line = reader.readLine()) != null) {
   process(line);
}
```

## Produced APIzation

[`APIzator2707333.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator2707333.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

/**
 * What is null in Java?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/2707333">https://stackoverflow.com/a/2707333</a>
 */
public class APIzator2707333 {

  public static void be() throws RuntimeException {
    String line;
    while ((line = reader.readLine()) != null) {
      process(line);
    }
  }
}

```