---
title: "[Q#4664893][A#4672083] How to manually set an authenticated user in Spring Security / SpringMVC"
question_title: "How to manually set an authenticated user in Spring Security / SpringMVC"
question_text: "After a new user submits a 'New account' form, I want to manually log that user in so they don't have to login on the subsequent page. The normal form login page going through the spring security interceptor works just fine. In the new-account-form controller I am creating a UsernamePasswordAuthenticationToken and setting it in the SecurityContext manually: On that same page I later check that the user is logged in with: This returns the authorities I set earlier in the authentication. All is well. But when this same code is called on the very next page I load, the authentication token is just UserAnonymous. I'm not clear why it did not keep the authentication I set on the previous request. Any thoughts? Just looking for some thoughts that might help me see what's happening here."
answer_text: "I had the same problem as you a while back. I can't remember the details but the following code got things working for me. This code is used within a Spring Webflow flow, hence the RequestContext and ExternalContext classes. But the part that is most relevant to you is the doAutoLogin method."
apization_code: "package com.stackoverflow.api;  /**  * How to manually set an authenticated user in Spring Security / SpringMVC  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/4672083\">https://stackoverflow.com/a/4672083</a>  */ public class APIzator4672083 {    public static String registerUser(     UserRegistrationFormBean userRegistrationFormBean,     RequestContext requestContext,     ExternalContext externalContext   ) {     try {       Locale userLocale = requestContext.getExternalContext().getLocale();       this.userService.createNewUser(           userRegistrationFormBean,           userLocale,           Constants.SYSTEM_USER_ID         );       String emailAddress = userRegistrationFormBean         .getChooseEmailAddressFormBean()         .getEmailAddress();       String password = userRegistrationFormBean         .getChoosePasswordFormBean()         .getPassword();       doAutoLogin(         emailAddress,         password,         (HttpServletRequest) externalContext.getNativeRequest()       );       return \"success\";     } catch (EmailAddressNotUniqueException e) {       MessageResolver messageResolvable = new MessageBuilder()         .error()         .source(UserRegistrationFormBean.PROPERTYNAME_EMAIL_ADDRESS)         .code(\"userRegistration.emailAddress.not.unique\")         .build();       requestContext.getMessageContext().addMessage(messageResolvable);       return \"error\";     }   }    private void doAutoLogin(     String username,     String password,     HttpServletRequest request   ) {     try {       // Must be called from request filtered by Spring Security, otherwise SecurityContextHolder is not updated       UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(         username,         password       );       token.setDetails(new WebAuthenticationDetails(request));       Authentication authentication =         this.authenticationProvider.authenticate(token);       logger.debug(\"Logging in with [{}]\", authentication.getPrincipal());       SecurityContextHolder.getContext().setAuthentication(authentication);     } catch (Exception e) {       SecurityContextHolder.getContext().setAuthentication(null);       logger.error(\"Failure in autoLogin\", e);     }   } }"
---

https://stackoverflow.com/q/4664893

After a new user submits a &#x27;New account&#x27; form, I want to manually log that user in so they don&#x27;t have to login on the subsequent page.
The normal form login page going through the spring security interceptor works just fine.
In the new-account-form controller I am creating a UsernamePasswordAuthenticationToken and setting it in the SecurityContext manually:
On that same page I later check that the user is logged in with:
This returns the authorities I set earlier in the authentication. All is well.
But when this same code is called on the very next page I load, the authentication token is just UserAnonymous.
I&#x27;m not clear why it did not keep the authentication I set on the previous request. Any thoughts?
Just looking for some thoughts that might help me see what&#x27;s happening here.


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
SecurityContextHolder.getContext().setAuthentication(authentication);
SecurityContextHolder.getContext().getAuthentication().getAuthorities();
```


## Original code snippet

https://stackoverflow.com/a/4672083

I had the same problem as you a while back. I can&#x27;t remember the details but the following code got things working for me. This code is used within a Spring Webflow flow, hence the RequestContext and ExternalContext classes. But the part that is most relevant to you is the doAutoLogin method.

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
public String registerUser(UserRegistrationFormBean userRegistrationFormBean,
                           RequestContext requestContext,
                           ExternalContext externalContext) {

    try {
        Locale userLocale = requestContext.getExternalContext().getLocale();
        this.userService.createNewUser(userRegistrationFormBean, userLocale, Constants.SYSTEM_USER_ID);
        String emailAddress = userRegistrationFormBean.getChooseEmailAddressFormBean().getEmailAddress();
        String password = userRegistrationFormBean.getChoosePasswordFormBean().getPassword();
        doAutoLogin(emailAddress, password, (HttpServletRequest) externalContext.getNativeRequest());
        return "success";

    } catch (EmailAddressNotUniqueException e) {
        MessageResolver messageResolvable 
                = new MessageBuilder().error()
                                      .source(UserRegistrationFormBean.PROPERTYNAME_EMAIL_ADDRESS)
                                      .code("userRegistration.emailAddress.not.unique")
                                      .build();
        requestContext.getMessageContext().addMessage(messageResolvable);
        return "error";
    }

}


private void doAutoLogin(String username, String password, HttpServletRequest request) {

    try {
        // Must be called from request filtered by Spring Security, otherwise SecurityContextHolder is not updated
        UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(username, password);
        token.setDetails(new WebAuthenticationDetails(request));
        Authentication authentication = this.authenticationProvider.authenticate(token);
        logger.debug("Logging in with [{}]", authentication.getPrincipal());
        SecurityContextHolder.getContext().setAuthentication(authentication);
    } catch (Exception e) {
        SecurityContextHolder.getContext().setAuthentication(null);
        logger.error("Failure in autoLogin", e);
    }

}
```

## Produced APIzation

[`APIzator4672083.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator4672083.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

/**
 * How to manually set an authenticated user in Spring Security / SpringMVC
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/4672083">https://stackoverflow.com/a/4672083</a>
 */
public class APIzator4672083 {

  public static String registerUser(
    UserRegistrationFormBean userRegistrationFormBean,
    RequestContext requestContext,
    ExternalContext externalContext
  ) {
    try {
      Locale userLocale = requestContext.getExternalContext().getLocale();
      this.userService.createNewUser(
          userRegistrationFormBean,
          userLocale,
          Constants.SYSTEM_USER_ID
        );
      String emailAddress = userRegistrationFormBean
        .getChooseEmailAddressFormBean()
        .getEmailAddress();
      String password = userRegistrationFormBean
        .getChoosePasswordFormBean()
        .getPassword();
      doAutoLogin(
        emailAddress,
        password,
        (HttpServletRequest) externalContext.getNativeRequest()
      );
      return "success";
    } catch (EmailAddressNotUniqueException e) {
      MessageResolver messageResolvable = new MessageBuilder()
        .error()
        .source(UserRegistrationFormBean.PROPERTYNAME_EMAIL_ADDRESS)
        .code("userRegistration.emailAddress.not.unique")
        .build();
      requestContext.getMessageContext().addMessage(messageResolvable);
      return "error";
    }
  }

  private void doAutoLogin(
    String username,
    String password,
    HttpServletRequest request
  ) {
    try {
      // Must be called from request filtered by Spring Security, otherwise SecurityContextHolder is not updated
      UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(
        username,
        password
      );
      token.setDetails(new WebAuthenticationDetails(request));
      Authentication authentication =
        this.authenticationProvider.authenticate(token);
      logger.debug("Logging in with [{}]", authentication.getPrincipal());
      SecurityContextHolder.getContext().setAuthentication(authentication);
    } catch (Exception e) {
      SecurityContextHolder.getContext().setAuthentication(null);
      logger.error("Failure in autoLogin", e);
    }
  }
}

```