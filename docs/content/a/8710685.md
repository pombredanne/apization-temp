---
title: "[Q#8710619][A#8710685] Why don't Java's +=, -=, *=, /= compound assignment operators require casting?"
question_title: "Why don't Java's +=, -=, *=, /= compound assignment operators require casting?"
question_text: "Until today, I thought that for example: is just a shortcut for: But what if we try this: Then i = i + j; will not compile but i += j; will compile fine. Does it mean that in fact i += j; is a shortcut for something like this i = (type of i) (i + j)?"
answer_text: "As always with these questions, the JLS holds the answer. In this case §15.26.2 Compound Assignment Operators. An extract: A compound assignment expression of the form E1 op= E2 is equivalent to E1 = (T)((E1) op (E2)), where T is the type of E1, except that E1 is evaluated only once. An example cited from §15.26.2 [...] the following code is correct: and results in x having the value 7 because it is equivalent to: In other words, your assumption is correct."
apization_code: "package com.stackoverflow.api;  /**  * Why don't Java's +=, -=, *=, /= compound assignment operators require casting?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/8710685\">https://stackoverflow.com/a/8710685</a>  */ public class APIzator8710685 {    public static void requireCast(short x, short x) throws RuntimeException {     x += 4.6;     x = (short) (x + 4.6);   } }"
---

https://stackoverflow.com/q/8710619

Until today, I thought that for example:
is just a shortcut for:
But what if we try this:
Then i = i + j; will not compile but i += j; will compile fine.
Does it mean that in fact i += j; is a shortcut for something like this
i = (type of i) (i + j)?


```java
i += j;
i = i + j;
int i = 5;
long j = 8;
```


## Original code snippet

https://stackoverflow.com/a/8710685

As always with these questions, the JLS holds the answer. In this case §15.26.2 Compound Assignment Operators. An extract:
A compound assignment expression of the form E1 op= E2 is equivalent to E1 = (T)((E1) op (E2)), where T is the type of E1, except that E1 is evaluated only once.
An example cited from §15.26.2
[...] the following code is correct:
and results in x having the value 7 because it is equivalent to:
In other words, your assumption is correct.

```java
short x = 3;
x += 4.6;
short x = 3;
x = (short)(x + 4.6);
```

## Produced APIzation

[`APIzator8710685.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/apizations/java/APIzator8710685.java)

```java
package com.stackoverflow.api;

/**
 * Why don't Java's +=, -=, *=, /= compound assignment operators require casting?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/8710685">https://stackoverflow.com/a/8710685</a>
 */
public class APIzator8710685 {

  public static void requireCast(short x, short x) throws RuntimeException {
    x += 4.6;
    x = (short) (x + 4.6);
  }
}

```