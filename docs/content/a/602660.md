---
title: "[Q#602636][A#602660] ConcurrentModificationException and a HashMap"
question_title: "ConcurrentModificationException and a HashMap"
question_text: "I am using persisting objects using JPA. The Main object has an owning One-Many relationship with another object. The other object is stored in a HashMap.  What sort of synchronisation would fix this problem?  It seems to happen at completely random times and is very unpredictable.  Here is the exception I get:"
answer_text: "This is not a synchronization problem.  This will occur if the underlying collection that is being iterated over is modified by anything other than the Iterator itself. This will throw a ConcurrentModificationException when the it.hasNext() is called the second time. The correct approach would be Assuming this iterator supports the remove() operation."
apization_code: "package com.stackoverflow.api;  import com.gargoylesoftware.htmlunit.javascript.host.Iterator; import org.apache.ibatis.ognl.internal.Entry;  /**  * ConcurrentModificationException and a HashMap  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/602660\">https://stackoverflow.com/a/602660</a>  */ public class APIzator602660 {    public static void concurrentmodificationexception() throws RuntimeException {     Iterator it = map.entrySet().iterator();     while (it.hasNext()) {       Entry item = it.next();       map.remove(item.getKey());     }     Iterator it = map.entrySet().iterator();     while (it.hasNext()) {       Entry item = it.next();       it.remove();     }   } }"
---

https://stackoverflow.com/q/602636

I am using persisting objects using JPA. The Main object has an owning One-Many relationship with another object. The other object is stored in a HashMap.  What sort of synchronisation would fix this problem?  It seems to happen at completely random times and is very unpredictable.  Here is the exception I get:


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
Exception in thread "pool-1-thread-1" java.util.ConcurrentModificationException
        at java.util.HashMap$HashIterator.nextEntry(Unknown Source)
        at java.util.HashMap$ValueIterator.next(Unknown Source)
        at org.hibernate.collection.AbstractPersistentCollection$IteratorProxy.next(AbstractPersistentCollection.java:555)
        at org.hibernate.engine.Cascade.cascadeCollectionElements(Cascade.java:296)
        at org.hibernate.engine.Cascade.cascadeCollection(Cascade.java:242)
        at org.hibernate.engine.Cascade.cascadeAssociation(Cascade.java:219)
        at org.hibernate.engine.Cascade.cascadeProperty(Cascade.java:169)
        at org.hibernate.engine.Cascade.cascade(Cascade.java:130)
```


## Original code snippet

https://stackoverflow.com/a/602660

This is not a synchronization problem.  This will occur if the underlying collection that is being iterated over is modified by anything other than the Iterator itself.
This will throw a ConcurrentModificationException when the it.hasNext() is called the second time.
The correct approach would be
Assuming this iterator supports the remove() operation.

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
Iterator it = map.entrySet().iterator();
while (it.hasNext())
{
   Entry item = it.next();
   map.remove(item.getKey());
}
Iterator it = map.entrySet().iterator();
   while (it.hasNext())
   {
      Entry item = it.next();
      it.remove();
   }
```

## Produced APIzation

[`APIzator602660.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator602660.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import com.gargoylesoftware.htmlunit.javascript.host.Iterator;
import org.apache.ibatis.ognl.internal.Entry;

/**
 * ConcurrentModificationException and a HashMap
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/602660">https://stackoverflow.com/a/602660</a>
 */
public class APIzator602660 {

  public static void concurrentmodificationexception() throws RuntimeException {
    Iterator it = map.entrySet().iterator();
    while (it.hasNext()) {
      Entry item = it.next();
      map.remove(item.getKey());
    }
    Iterator it = map.entrySet().iterator();
    while (it.hasNext()) {
      Entry item = it.next();
      it.remove();
    }
  }
}

```