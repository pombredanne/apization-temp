---
title: "[Q#1347949][A#1348018] Correct way to initialize HashMap and can HashMap hold different value types?"
question_title: "Correct way to initialize HashMap and can HashMap hold different value types?"
question_text: "So I have two questions about HashMaps in Java: What is the correct way to initialize a HashMap? I think it might be best in my situation to use: But Eclipse keeps suggesting that I use: Which is better? Can a HashMap hold different types of objects/data types as values? For example, would this work and be OK: In the first put(), I want an int as a value, in the second an int[], and third a string. Is this okay to do in Java with HashMaps? Also, is it okay to store a HashMap as a value within a HashMap?"
answer_text: "It really depends on what kind of type safety you need. The non-generic way of doing it is best done as: Note that x is typed as a Map. this makes it much easier to change implementations (to a TreeMap or a LinkedHashMap) in the future. You can use generics to ensure a certain level of type safety: In Java 7 and later you can do The above, while more verbose, avoids compiler warnings. In this case the content of the HashMap can be any Object, so that can be Integer, int[], etc. which is what you are doing. If you are still using Java 6, Guava Libraries (although it is easy enough to do yourself) has a method called newHashMap() which avoids the need to duplicate the generic typing information when you do a new. It infers the type from the variable declaration (this is a Java feature not available on constructors prior to Java 7). By the way, when you add an int or other primitive, Java is autoboxing it. That means that the code is equivalent to: You can certainly put a HashMap as a value in another HashMap, but I think there are issues if you do it recursively (that is put the HashMap as a value in itself)."
apization_code: "package com.stackoverflow.api;  import java.util.HashMap; import java.util.Map;  /**  * Correct way to initialize HashMap and can HashMap hold different value types?  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/1348018\">https://stackoverflow.com/a/1348018</a>  */ public class APIzator1348018 {    public static void way(Map<String, Object> x) throws RuntimeException {     Map x = new HashMap();     Map<String, Object> x = new HashMap<String, Object>();   } }"
---

https://stackoverflow.com/q/1347949

So I have two questions about HashMaps in Java:
What is the correct way to initialize a HashMap? I think it might be best in my situation to use:
But Eclipse keeps suggesting that I use:
Which is better?
Can a HashMap hold different types of objects/data types as values? For example, would this work and be OK:
In the first put(), I want an int as a value, in the second an int[], and third a string. Is this okay to do in Java with HashMaps? Also, is it okay to store a HashMap as a value within a HashMap?


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
HashMap x = new HashMap();
HashMap<something, something> map = new HashMap();
map.put("one", 1);
map.put("two", {1, 2});
map.put("three", "hello");
```


## Original code snippet

https://stackoverflow.com/a/1348018

It really depends on what kind of type safety you need. The non-generic way of doing it is best done as:
Note that x is typed as a Map. this makes it much easier to change implementations (to a TreeMap or a LinkedHashMap) in the future.
You can use generics to ensure a certain level of type safety:
In Java 7 and later you can do
The above, while more verbose, avoids compiler warnings. In this case the content of the HashMap can be any Object, so that can be Integer, int[], etc. which is what you are doing.
If you are still using Java 6, Guava Libraries (although it is easy enough to do yourself) has a method called newHashMap() which avoids the need to duplicate the generic typing information when you do a new. It infers the type from the variable declaration (this is a Java feature not available on constructors prior to Java 7).
By the way, when you add an int or other primitive, Java is autoboxing it. That means that the code is equivalent to:
You can certainly put a HashMap as a value in another HashMap, but I think there are issues if you do it recursively (that is put the HashMap as a value in itself).

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
Map x = new HashMap();
Map<String, Object> x = new HashMap<String, Object>();
Map<String, Object> x = new HashMap<>();
x.put("one", Integer.valueOf(1));
```

## Produced APIzation

[`APIzator1348018.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator1348018.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import java.util.HashMap;
import java.util.Map;

/**
 * Correct way to initialize HashMap and can HashMap hold different value types?
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/1348018">https://stackoverflow.com/a/1348018</a>
 */
public class APIzator1348018 {

  public static void way(Map<String, Object> x) throws RuntimeException {
    Map x = new HashMap();
    Map<String, Object> x = new HashMap<String, Object>();
  }
}

```