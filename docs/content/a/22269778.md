---
title: "[Q#21163108][A#22269778] Custom thread pool in Java 8 parallel stream"
question_title: "Custom thread pool in Java 8 parallel stream"
question_text: "Is it possible to specify a custom thread pool for Java 8 parallel stream? I can not find it anywhere. Imagine that I have a server application and I would like to use parallel streams. But the application is large and multi-threaded so I want to compartmentalize it. I do not want a slow running task in one module of the applicationblock tasks from another module. If I can not use different thread pools for different modules, it means I can not safely use parallel streams in most of real world situations. Try the following example. There are some CPU intensive tasks executed in separate threads. The tasks leverage parallel streams. The first task is broken, so each step takes 1 second (simulated by thread sleep). The issue is that other threads get stuck and wait for the broken task to finish. This is contrived example, but imagine a servlet app and someone submitting a long running task to the shared fork join pool."
answer_text: "There actually is a trick how to execute a parallel operation in a specific fork-join pool. If you execute it as a task in a fork-join pool, it stays there and does not use the common one. The trick is based on ForkJoinTask.fork which specifies: \"Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the ForkJoinPool.commonPool() if not inForkJoinPool()\""
apization_code: "package com.stackoverflow.api;  import java.util.concurrent.ForkJoinPool; import java.util.stream.IntStream;  /**  * Custom thread pool in Java 8 parallel stream  *  * @author APIzator  * @see <a href=\"https://stackoverflow.com/a/22269778\">https://stackoverflow.com/a/22269778</a>  */ public class APIzator22269778 {    public static void stream() throws RuntimeException {     ForkJoinPool forkJoinPool = new ForkJoinPool(2);     forkJoinPool       .submit(         () ->           IntStream             .range(1, 1_000_000)             .parallel()             .filter(PrimesPrint::isPrime)             .collect(toList())       )       .get();   } }"
---

https://stackoverflow.com/q/21163108

Is it possible to specify a custom thread pool for Java 8 parallel stream? I can not find it anywhere.
Imagine that I have a server application and I would like to use parallel streams. But the application is large and multi-threaded so I want to compartmentalize it. I do not want a slow running task in one module of the applicationblock tasks from another module.
If I can not use different thread pools for different modules, it means I can not safely use parallel streams in most of real world situations.
Try the following example. There are some CPU intensive tasks executed in separate threads.
The tasks leverage parallel streams. The first task is broken, so each step takes 1 second (simulated by thread sleep). The issue is that other threads get stuck and wait for the broken task to finish. This is contrived example, but imagine a servlet app and someone submitting a long running task to the shared fork join pool.


<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
public class ParallelTest {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService es = Executors.newCachedThreadPool();

        es.execute(() -> runTask(1000)); //incorrect task
        es.execute(() -> runTask(0));
        es.execute(() -> runTask(0));
        es.execute(() -> runTask(0));
        es.execute(() -> runTask(0));
        es.execute(() -> runTask(0));


        es.shutdown();
        es.awaitTermination(60, TimeUnit.SECONDS);
    }

    private static void runTask(int delay) {
        range(1, 1_000_000).parallel().filter(ParallelTest::isPrime).peek(i -> Utils.sleep(delay)).max()
                .ifPresent(max -> System.out.println(Thread.currentThread() + " " + max));
    }

    public static boolean isPrime(long n) {
        return n > 1 && rangeClosed(2, (long) sqrt(n)).noneMatch(divisor -> n % divisor == 0);
    }
}
```


## Original code snippet

https://stackoverflow.com/a/22269778

There actually is a trick how to execute a parallel operation in a specific fork-join pool. If you execute it as a task in a fork-join pool, it stays there and does not use the common one.
The trick is based on ForkJoinTask.fork which specifies: &quot;Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the ForkJoinPool.commonPool() if not inForkJoinPool()&quot;

<div class="code-logo"><img src="/stackoverflow.png" /></div>

```java
ForkJoinPool forkJoinPool = new ForkJoinPool(2);
forkJoinPool.submit(() ->
    //parallel task here, for example
    IntStream.range(1, 1_000_000).parallel().filter(PrimesPrint::isPrime).collect(toList())
).get();
```

## Produced APIzation

[`APIzator22269778.java`](https://github.com/pasqualesalza/apization-temp-data/raw/master/search/APIzator22269778.java)

<div class="code-logo"><img src="/apizator.png" /></div>

```java
package com.stackoverflow.api;

import java.util.concurrent.ForkJoinPool;
import java.util.stream.IntStream;

/**
 * Custom thread pool in Java 8 parallel stream
 *
 * @author APIzator
 * @see <a href="https://stackoverflow.com/a/22269778">https://stackoverflow.com/a/22269778</a>
 */
public class APIzator22269778 {

  public static void stream() throws RuntimeException {
    ForkJoinPool forkJoinPool = new ForkJoinPool(2);
    forkJoinPool
      .submit(
        () ->
          IntStream
            .range(1, 1_000_000)
            .parallel()
            .filter(PrimesPrint::isPrime)
            .collect(toList())
      )
      .get();
  }
}

```